- Class: meta
  Course: DataScienceAndR
  Lesson: Project-ROpenData-Four-Asian-Tigers
  Author: Cheng-Yu Lin (aha)
  Type: Standard
  Organization: Taiwan R User Group
  Version: 0.0.1

- Class: text
  Output: 亞洲四小龍是指自1970年代起經濟迅速發展的四個亞洲經濟體：南韓、臺灣、香港、新加坡。這些位於東亞和東南亞的國家或地區在1970年代到1990年代經濟發展高速成長，但是，在這之前他們都只以農業和輕工業為主。它們利用西方發達國家向發展中國家轉移勞動密集型產業的機會，吸引外國大量的資金和技術，利用本地廉價而良好的勞動力優勢適時調整經濟發展策略，迅速走上發展道路，並且成為繼日本國以後亞洲新興的發達國家或地區，也成為東亞和東南亞地區的經濟火車頭之一，其成功的經濟發展過程和經驗是發展經濟學研究的典型例子。亞洲四小龍的稱呼在其經濟高速發展時期較為常見，1990年代後較為少用。

- Class: text
  Output: 整體的發展趨勢是: 農業, 輕工業 → 吸引資金與技術 + 本地勞動力(出口導向) → 東亞與東南亞主要經濟體( 1970- 1990 ).

- Class: text
  Output: 今天我們的問題是: 過了2000年，時間來到2015，台灣的GDP成長依舊是四小龍之首?

- Class: text
  Output: 這次練習中，國家資料來源是取自： Worldbank<http://data.worldbank.org/> 與台灣主計處 <http://statdb.dgbas.gov.tw/pxweb/Dialog/NI.asp>。 目前將2016-03-17時下載後的檔案解壓縮，並且把要用到的搬到課程目錄之下。其中台灣主計處資料因為預設都是big5，下載後用其他軟體轉成utf8。

- Class: cmd_question
  Output: 由於網路在傳輸課程資料時，可能會出錯，所以我們可以先用R 的內建 功能檢查檔案的內容是不是在安裝過程中毀損。請同學輸入： `tools::md5sum(RawData_KR)`。完成後課程會在背景自動比對結果。
  CorrectAnswer: tools::md5sum(RawData_KR)
  AnswerTests: omnitest('tools::md5sum(RawData_KR)', 'd38cb9e3530432181ead18a421b2725e')
  Hint: 如果輸出結果不是`"d38cb9e3530432181ead18a421b2725e"`，代表檔案 已經毀損，請移除課程（`uninstall_all_courses`）後重新安裝課程。

- Class: text
  Output: 這裡的`::`代表說，`md5sum`這個函數是來自`tools`這個套件。 這是近代R 語言新增的一種類似namespace的功能，是個很大的進步。


- Class: cmd_question
  Output: 各行業的GDP 資料則下載自<http://statdb.dgbas.gov.tw/pxweb/dialog/statfile9L.asp>。
    檔案路徑已經放入`gdp_path`之中。請同學再次利用`tools::md5sum(gdp_path)` 來檢查檔案內容。
  CorrectAnswer: tools::md5sum(gdp_path)
  AnswerTests: omnitest('tools::md5sum(gdp_path)', '9eee2ac49d017dbb79c8a802b55eb3bc')
  Hint: tools::md5sum(gdp_path)
- Class: cmd_question
  Output: 首先，就讓我們把資料載入到R 之中吧！ 首先我們來一起處理電力資料。 一般來說，在讀中文資料之前，我們要先了解資料的編碼。 由於官方文件上並沒有編碼的資訊，所以在實務上只能一個個嘗試。
    通常政府的官方資料如果沒有特別註明，建議就是從BIG-5開始嘗試。 請同學試試看：`readLines(file(power_path, encoding
    = "BIG-5"), n = 10)` 這裡的`file`是R 建立一個檔案連結的方式。file的第一個參數是檔案的路徑， `encoding`則代表這個檔案內容的編碼。
    `readLines`則是輸出一個字串向量，而這個向量是從檔案中一行一行的把內容讀出來的。 也就是說，檔案裡面的每一行會變成一個向量中的字串。 參數`n =
    10`則代表我們只讀最前面的10行。 這是實務上的一個好習慣：先看一看檔案的一開始。
  CorrectAnswer: readLines(file(power_path, encoding = "BIG-5"), n = 10)
  AnswerTests: omnitest('readLines(file(power_path, encoding = "BIG-5"), n = 10)')
  Hint: readLines(file(power_path, encoding = "BIG-5"), n = 10)
- Class: text
  Output: 如果成功看到中文字，就是猜對Encoding了。
- Class: cmd_question
  Output: 接下來，從螢幕上我們可以看到，這個檔案的分隔符號會是應該是`";\t"`， （還滿少見的）。另外在中間有部分資料的分隔符號只有`"\t"`。 可惜R
    的能接受的分隔符號，通常只能是一個字元。 資料不大，所以我們可以自己切資料吧！ 首先，請同學用readLines把所有資料讀出來，並且將資料都存到`power`這個變數。
  CorrectAnswer: power <- readLines(file(power_path, encoding = "BIG-5"))
  AnswerTests: check_val("power", readLines(file(power_path, encoding = "BIG-5")))
  Hint: power <- readLines(file(power_path, encoding = "BIG-5"))
- Class: text
  Output: 其實這樣混亂、不好整理的資料，是我們在處理實際資料時 常常遇到的狀況。而且我們也常常犯錯，導致要重頭開始重新整理。
- Class: cmd_question
  Output: 在R 中，我們可以使用`strsplit`來切割字串。 `strsplit`的參數x 是要被切割的字串，split是定位分割點的字串。 請同學呼叫`strsplit`來用`";?\t"`切割`power`，並且將結果儲存到
    `power.split`中。 `";?\t"`在這邊代表，這個分號`;`是可有可無的。這是為了讓R 能夠 同時處理分隔符號為`";\t"`或`"\t"`的狀況。
  CorrectAnswer: power.split <- strsplit(power, ";?\t")
  AnswerTests: |
    check_val("power.split", strsplit(power, .delim))
  Hint: power.split <- strsplit(power, ";?\t")
- Class: cmd_question
  Output: 使用`do.call`可以讓我們把`power.split`組裝成一個character matrix。 請同學輸入：`power.mat <-
    do.call(rbind, power.split)`。 `power.split`是一個R 物件向量，而rbind是吃一個任意參數的函數， 並且把每個參數當成一個row，組裝出一個matrix。
    `do.call`會把在這裡的功能，就等價於：`rbind(power.split[[1]], power.split[[2]], ...)` 把`power.split`拆解後，全部當成參數丟到rbind去做組裝。
  CorrectAnswer: power.mat <- do.call(rbind, power.split)
  AnswerTests: omnitest('power.mat <- do.call(rbind, power.split)')
  Hint: power.mat <- do.call(rbind, power.split)
- Class: cmd_question
  Output: 我們差不多把電力資料整理的差不多了，只剩下最後一步：把`power.mat` 轉換成一個data.frame，並且讓各個column擁有正確的形態。
    但是這最後一步卻有許多小步驟。 首先，我們把`power.mat`用`data.frame`轉換成`power.df` 這裡要注意的是，`data.frame`在轉換的時候，這裡有下參數：`stringsAsFactors
    = FALSE`， 否則欄位會被轉換成factor，在做後續字串處理時，有時候會出錯。
  CorrectAnswer: power.df <- data.frame(power.mat, stringsAsFactors = FALSE)
  AnswerTests: any_of_exprs('power.df <- data.frame(power.mat, stringsAsFactors =
    FALSE)', 'power.df = data.frame(power.mat, stringsAsFactors = FALSE)')
  Hint: power.df <- data.frame(power.mat, stringsAsFactors = FALSE)
- Class: cmd_question
  Output: 然後，我們設定`power.df`的欄位名稱（colnames）依序為： `c("id", "name", "year", "power")`
    請同學使用：`colnames(power.df) <- ` 的語法來指定power.df的 colnames。
  CorrectAnswer: colnames(power.df) <- c("id", "name", "year", "power")
  AnswerTests: any_of_exprs('colnames(power.df) <- c("id", "name", "year", "power")',
    'colnames(power.df) = c("id", "name", "year", "power")')
  Hint: colnames(power.df) <- c("id", "name", "year", "power")
- Class: cmd_question
  Output: 接下來，我們設定讓power.df的name欄位是`factor`。 請使用`factor`這個函數。
  CorrectAnswer: power.df$name <- factor(power.df$name)
  AnswerTests: |
    check_val("power.df", local({
      retval <- get("power.df", envir = globalenv())
      retval$name <- factor(retval$name)
      retval
    }))
  Hint: power.df$name <- factor(power.df$name)
- Class: cmd_question
  Output: 接下來，我們設定讓power.df的year欄位是`integer`。 請使用`as.integer`這個函數。
  CorrectAnswer: power.df$year <- as.integer(power.df$year)
  AnswerTests: |
    check_val("power.df", local({
      retval <- get("power.df", envir = globalenv())
      retval$year <- as.integer(retval$year)
      retval
    }))
  Hint: power.df$year <- as.integer(power.df$year)
- Class: cmd_question
  Output: 接下來，我們設定讓power.df的power欄位是`numeric`。 請使用`as.numeric`這個函數。
  CorrectAnswer: power.df$power <- as.numeric(power.df$power)
  AnswerTests: |
    check_val("power.df", local({
      retval <- get("power.df", envir = globalenv())
      retval$power <- as.numeric(retval$power)
      retval
    }))
  Hint: power.df$power <- as.numeric(power.df$power)
- Class: cmd_question
  Output: 大功造成了，請輸入`head(power.df)`來檢視一下我們整理好的 data.frame物件。同時我們也會再檢驗一次power.df看看是否正確。
  CorrectAnswer: head(power.df)
  AnswerTests: |
    test_all(
      omnitest("head(power.df)"),
      check_val("power.df", local({
        retval <- data.frame(get("power.mat", envir = globalenv()), stringsAsFactors = FALSE)
        colnames(retval) <- c("id", "name", "year", "power")
        retval$name <- factor(retval$name)
        retval$year <- as.integer(retval$year)
        retval$power <- as.numeric(retval$power)
        retval
      })))
  Hint: head(power.df)
- Class: cmd_question
  Output: 由於我們在抓資料的分割點時，很有可能會抓錯。所以保險起見， 在這個時間點我們要檢查資料是否有清理乾淨。 在R 中，如果中間資料有任何錯誤的話，常常會有NA產生。
    所以一個方法就是用`is.na`檢查`power.df`的四個欄位中間有沒有NA。 `all`這個函數，則可以檢查一個邏輯向量的所有的值是否為TRUE。 請同學組合`is.na`和`all`來檢查`power.df`的欄位是否包含NA。
  CorrectAnswer: all(!is.na(power.df))
  AnswerTests: |
    test_all(
      omnitest("all(!is.na(power.df))"),
      val_is(TRUE))
  Hint: all(!is.na(power.df))
- Class: cmd_question
  Output: 接下來，我們來運用dplyr和ggplot2這兩個套件將power.df的資料繪製成圖表。 請先安裝dplyr套件。
  CorrectAnswer: check_then_install("dplyr", "0.4.3")
  AnswerTests: test_package_version("dplyr", "0.4.3")
  Hint: 請安裝套件dplyr
- Class: cmd_question
  Output: 請再安裝ggplot2套件
  CorrectAnswer: check_then_install("ggplot2", "1.0.1")
  AnswerTests: test_package_version("ggplot2", "1.0.1")
  Hint: 請安裝套件ggplot2
- Class: cmd_question
  Output: 使用套件的起手式：載入dplyr
  CorrectAnswer: library(dplyr)
  AnswerTests: test_search_path("dplyr")
  Hint: library(dplyr)
- Class: cmd_question
  Output: 這裡的`id`欄位，是中華民國行業標準分類的代碼。 這個代碼的最大類， 都是用英文字母標示的。所以我們就用regular expression來找出
    所有英文開頭的`id`。 `grepl("^[A-Z]", input)`會判斷input這個字串向量的值，是不是符合 字母開頭。如果是的話，就傳TRUE，否則就是FALSE。
    和dplyr套件的`filter`搭配使用，我們就可以快速取得所有大類的資料。 請同學將這樣的資料存到`power.target`這個變數之中。
  CorrectAnswer: power.target <- filter(power.df, grepl("^[A-Z]", id))
  AnswerTests: any_of_exprs('power.target <- filter(power.df, grepl("^[A-Z]", id))',
    'power.target = filter(power.df, grepl("^[A-Z]", id))')
  Hint: power.target <- filter(power.df, grepl("^[A-Z]", id))
- Class: cmd_question
  Output: filter 不只可以幫我們挑出主要的行業類別，還可以挑選年度。 所以我們可以繪製每年度，主要行業別的用電比較。 首先，我們先整理出91年度的主要類別，並且存放到`power.target`之中。
  CorrectAnswer: power.target <- filter(power.df, grepl("^[A-Z]", id), year == 91)
  AnswerTests: check_val("power.target", filter(get("power.df", envir = globalenv()),
    grepl("^[A-Z]", id), year == 91))
  Hint: power.target <- filter(power.df, grepl("^[A-Z]", id), year == 91)
- Class: cmd_question
  Output: 我們可以利用power.target來繪製一個barchart來呈現 各種行業別的用電量。首先，還是要先載入ggplot2。
  CorrectAnswer: library(ggplot2)
  AnswerTests: test_search_path("ggplot2")
  Hint: library(ggplot2)
- Class: cmd_question
  Output: 我們先建立ggplot2的底圖物件。 這裡我們會用到`aes`這個函數，來辨識在`power.target`的欄位，哪一欄要放到x 軸， 哪一欄，要放到y
    軸。x 軸的通常放的是分類，而y 放的是我們想要觀測的數據的值。 請同學修改以下的指令，將ggplot2的底圖物件寫入變數`g`。 指令是：`g <- ggplot(power.target,
    aes(x = <欄位名稱1>, y = <欄位名稱2>))`
  CorrectAnswer: g <- ggplot(power.target, aes(x = name, y = power))
  AnswerTests: omnitest('g <- ggplot(power.target, aes(x = name, y = power))')
  Hint: 我們可以用`colnames(power.target)`來看一下欄位的名稱，以及用 `head(power.target)`來簡單看一下`power.target`的內容。這裡其實id和
    name都可以，那為了讓圖表更清楚，我們先採用name當x軸的說明。
- Class: cmd_question
  Output: 建立底圖之後，我們就要選用適當的圖形工具來適當的呈現我們要看的工具。 這裡我們來用`geom_bar`來呈現我們要資料。 大家可以試試看：`g
    + geom_bar(stat = "identity")`
  CorrectAnswer: g + geom_bar(stat = "identity")
  AnswerTests: omnitest('g + geom_bar(stat = "identity")')
  Hint: g + geom_bar(stat = "identity")
- Class: text
  Output: 有些使用者可能會無法在圖上顯示中文。這可能是字形的問題。 如果是蘋果牌的使用者，可以更改預設的字形來顯示中文： `theme_set(theme_gray(base_family
    = "STKaiti"))`
- Class: cmd_question
  Output: 另外我們也會發現整個x 軸容納不下我們的說明文字。 這時候可以透過設定`xlab`的字體方向，來解決這個問題： `theme(axis.text.x
    = element_text(angle = 90))` 請注意，ggplot2在設定類型時，是直接透過在程式碼的最後用`+`來加上 `theme(...)`來作處理的。
    我建議各位同學先使用上下鍵盤，找出剛剛繪圖的指令，然後在最後加上： `+ theme(axis.text.x = element_text(angle =
    90))`
  CorrectAnswer: g + geom_bar(stat = "identity") + theme(axis.text.x = element_text(angle
    = 90))
  AnswerTests: omnitest('g + geom_bar(stat = "identity") + theme(axis.text.x = element_text(angle
    = 90))')
  Hint: g + geom_bar(stat = "identity") + theme(axis.text.x = element_text(angle =
    90))
- Class: text
  Output: 從圖上顯示，我們可以注意到在民國91年的時候， 在各行業中，製造業還是消耗了最多的電力。
- Class: cmd_question
  Output: 在ggplot2，我們可以把bar chart更改成pie chart。 請同學試試看：`ggplot(power.target, aes(x
    = "", y = power, fill = name)) + geom_bar(stat = "identity") + coord_polar(theta
    = "y")` 如果同學覺得這個指令很冗長的話，可以輸入`skip()`來跳過。
  CorrectAnswer: ggplot(power.target, aes(x = "", y = power, fill = name)) + geom_bar(stat
    = "identity") + coord_polar(theta = "y")
  AnswerTests: omnitest('ggplot(power.target, aes(x = "", y = power, fill = name))
    + geom_bar(stat = "identity") + coord_polar(theta = "y")')
  Hint: ggplot(power.target, aes(x = "", y = power, fill = name)) + geom_bar(stat
    = "identity") + coord_polar(theta = "y")
- Class: text
  Output: 事實上ggplot2對pie chart的支援並不好，而這是有理由的。 有興趣的同學可以讀一讀<http://www.r-chart.com/2010/07/pie-charts-in-ggplot2.html>
    裡面提到一些統計學家對pie chart的批評。
- Class: text
  Output: 而根據這個pie chart，我們至少可以了解 在民國91年製造業消耗了我們超過一半的電力。
- Class: text
  Output: 一個我們也許會感興趣的問題是： 我們的GDP是不是大部份也來自於製造業呢？
- Class: text
  Output: 接著，我們來整理GDP的資料...
- Class: cmd_question
  Output: 透過一樣的要領，我們應該先用`readLines`先看看`gdp_path` 的資料內容。請同學檢視`gdp_path`這個檔案的前20行。
  CorrectAnswer: readLines(file(gdp_path, encoding = "BIG-5"), n = 20)
  AnswerTests: omnitest('readLines(file(gdp_path, encoding = "BIG-5"), n = 20)')
  Hint: readLines(file(gdp_path, encoding = "BIG-5"), n = 20)
- Class: text
  Output: 一些不熟悉R 的同學可能會被`\"`這個符號給搞混了。 由於`"`在R 中是代表字串的開始和結束，所以R 會在顯示字串時， 在`"`之前加註`\`，所以一個`\"`實際上就是一個`"`
- Class: cmd_question
  Output: 另一個避免`\"`干擾的方式，是使用`cat`這函數。 請同學試試看：`cat(readLines(file(gdp_path, encoding
    = "BIG-5"), n = 20), sep = "\n")`
  CorrectAnswer: cat(readLines(file(gdp_path, encoding = "BIG-5"), n = 20), sep =
    "\n")
  AnswerTests: omnitest('cat(readLines(file(gdp_path, encoding = "BIG-5"), n = 20),
    sep = "\n")')
  Hint: cat(readLines(file(gdp_path, encoding = "BIG-5"), n = 20), sep = "\n")
- Class: text
  Output: 上一個問題的答案，其實牽涉到了三層函數：
- Class: text
  Output: 我們先呼叫`file(gdp_path, encoding = "BIG-5")`建立一個connection。 connection是R 處理檔案的專業術語，如果比較不熟悉程式設計的同學，就先把
    connection當成檔案的代理就好。
- Class: text
  Output: 接著，我們使用`readLines`處理`file`回傳的物件。這是第二層。 這裡我們指定參數`n=20`，代表我們要從connection的最前面讀取前20行。
- Class: text
  Output: 最後，我們把`readLines`回傳的20個字串交給`cat`作處理。 `cat`會直接把字串內容印到R 的console上，而且我們指定每一個
    字串之間要插入一個斷行。
- Class: cmd_question
  Output: 這樣一層一層疊上去的寫法，很容易讓程式變的很複雜。 Stefan Milton Bache推出了一個R 套件很好地解決了這個問題： `magrittr`。我們在安裝`dplyr`之後，應該已經安裝了這個套件了。
    因此，請同學直接輸入：`library(magrittr)`
  CorrectAnswer: library(magrittr)
  AnswerTests: test_search_path("magrittr")
  Hint: library(magrittr)
- Class: cmd_question
  Output: 回顧一下我們剛剛做的事情： 把`file(gdp_path, encodoing = "BIG-5")` 得到的物件給 `readLines(...,
    n = 20)` 再把得到的物件給 `cat(..., sep = "\n")`。 這裡的`...`就代表從上一個函數得到的物件。使用`magrittr`後，
    我們的寫法就變成：`file(gdp_path, encoding = "BIG-5") %>% readLines(n = 20) %>% cat(sep
    = "\n")` 請同學試試看
  CorrectAnswer: file(gdp_path, encoding = "BIG-5") %>% readLines(n = 20) %>% cat(sep
    = "\n")
  AnswerTests: omnitest('file(gdp_path, encoding = "BIG-5") %>% readLines(n = 20)
    %>% cat(sep = "\n")')
  Hint: file(gdp_path, encoding = "BIG-5") %>% readLines(n = 20) %>% cat(sep = "\n")
- Class: text
  Output: 在實務上，我們會在`%>%`後斷行，增加程式的可讀性。
- Class: text
  Output: 回歸正傳，我們第一個要看的，是檔案中的分隔符號是什麼。 大家在看過檔案內容之後，應該會同意：分隔符號是`,` 另外大家也會注意到這個檔案中，字串的內容的前後會加上`"`。
    另外每一列的欄位數目也不一致，所以不能簡單用`read.csv`解決。 因為資料量不大，我們還是全部用`readLines`讀進來後再用`strsplit`
    自己切吧！
- Class: cmd_question
  Output: 和剛剛的電力資料一樣，請讓我們先用`readLines`把資料全部 載入並且存到`gdp`這個變數之中。
  CorrectAnswer: gdp <- file(gdp_path, encoding = "BIG-5") %>% readLines()
  AnswerTests: |
    check_val("gdp", local({
      file(gdp_path, encoding = "BIG-5") %>% readLines()
    }))
  Hint: gdp <- file(gdp_path, encoding = "BIG-5") %>% readLines()
- Class: cmd_question
  Output: 接著，我們利用`strsplit`，用`","`當分隔符號， 將讀入的gdp資料切成list。請將結果存到`gdp.split`
  CorrectAnswer: gdp.split <- strsplit(gdp, ",")
  AnswerTests: |
    check_val("gdp.split", local({
      strsplit(get("gdp", envir = globalenv()), ",")
    }))
  Hint: gdp.split <- strsplit(gdp, ",")
- Class: cmd_question
  Output: 仔細一點的話，我們能注意到，年份的資料在切割後，長度都是1 。 所以讓我們選取`gdp.split`這個list中，`length`為1 的值。這部分，可以
    利用`sapply`這個函數來查詢。請同學試試看： `(sapply(gdp.split, length) == 1) %>% which` 這裡的`sapply(gdp.split,
    lenght)`相當於建立一個向量，並且讓第一個值 為`length(gdp.split[[1]])`，第二個值為`length(gdp.split[[2]])`，以此類推。
  CorrectAnswer: (sapply(gdp.split, length) == 1) %>% which
  AnswerTests: omnitest('(sapply(gdp.split, length) == 1) %>% which')
  Hint: (sapply(gdp.split, length) == 1) %>% which
- Class: cmd_question
  Output: 我們可以看一下，這些長度為一的行的內容： 請同學輸入：`gdp.split[(sapply(gdp.split, length) == 1) %>%
    which]`
  CorrectAnswer: gdp.split[(sapply(gdp.split, length) == 1) %>% which]
  AnswerTests: omnitest('gdp.split[(sapply(gdp.split, length) == 1) %>% which]')
  Hint: gdp.split[(sapply(gdp.split, length) == 1) %>% which]
- Class: cmd_question
  Output: 我們可以看到，只有前7 個index 是真的代表年份。 最後幾個index 其實只有指到這個檔案的一些說明。 所以我們利用`head`這個函數，拿出前7
    個index，並存到：`year.index`之中。 請同學輸入：`year.index <- (sapply(gdp.split, length) ==
    1) %>% which %>% head(7)`
  CorrectAnswer: year.index <- (sapply(gdp.split, length) == 1) %>% which %>% head(7)
  AnswerTests: omnitest('year.index <- (sapply(gdp.split, length) == 1) %>% which
    %>% head(7)')
  Hint: year.index <- (sapply(gdp.split, length) == 1) %>% which %>% head(7)
- Class: script
  Output: 接著我們可以利用for 迴圈來切出這份資料。這部分請同學 參考路徑在`gdp_df_path`的這個檔案，修改它，讓我們能得到`gdp_df`
    這個整理乾淨過後的data.frame。 你可以利用`browseURL(gdp_df_path)`來打開參考檔案。把檔案 的內容複製到gdp_df.R之中，並且再完成之後，輸入：`submit()`
  Script: gdp_df.R
  AnswerTests: "check_val(\"gdp.df\", local({\n  # 開始的index\n  year.index.start <-
    year.index\n  # 結束的index\n  ## 我們拿下一個開始的index - 1 當成現在結尾的index\n  year.index.end
    <- c(tail(year.index, -1), length(gdp.split))\n  # 開始撰寫for迴圈\n  ## 我們先建立每一年份整理出來的gdp
    資料\n  ## 這些資料會被放到gdp.df.components之中\n  gdp.df.components <- list()\n  # 請填寫正確的for
    迴圈的範圍\n  for(i in 1:7) {\n    # 針對特定年份做處理的程式碼\n    ## 開始的index\n    start <- year.index.start[i]\n
    \   ## 結束的index\n    end <- year.index.end[i]\n    ## 年份的資料在第一筆\n    year <- gdp.split[[start]]
    %>%\n      ## 將 \"2007\" ==> 2007，將\"用空白替換掉\n      gsub(pattern = '\"', replacement
    = '')\n    ## 只抽出這次要處理的資料\n    target <- gdp.split[start:end]\n    ## 挑出長度是3 的，做rbind\n
    \   target.mat <- do.call(rbind, \n                          target[sapply(target,
    length) == 3])\n    ## 原本的第一行是空白，我們改成放年份\n    target.mat[,1] <- year\n    ## 處理第二行中的\"\n
    \   target.mat[,2] <- gsub('\"', '', target.mat[,2])\n    ## 將這輪處理的資料，放到gdp.df.components\n
    \   gdp.df.components[[i]] <- target.mat\n  }\n  gdp.df <- do.call(rbind, gdp.df.components)
    %>% \n    ## 我們先不把資料轉成factor\n    data.frame(stringsAsFactors = FALSE)\n  colnames(gdp.df)
    <- c(\"year\", \"name\", \"gdp\")\n  ## 把year 轉成integer\n  gdp.df$year <- as.integer(gdp.df$year)\n
    \ ## 把name 轉成character\n  gdp.df$name <- as.character(gdp.df$name)\n  ## 把gdp
    轉成numeric\n  gdp.df$gdp <- as.numeric(gdp.df$gdp)\n  gdp.df <- filter(gdp.df,
    !is.na(gdp))\n}))\n"
- Class: text
  Output: |
    接下來我們比對兩者的資料，好計算使用能源的效率。
    但是，這不容易... 比對資料最重要的，是兩者的一致性。
- Class: cmd_question
  Output: |
    我們先看看gdp.df資料中的行業別。請同學輸入：`unique(gdp.df$name)`
  CorrectAnswer: unique(gdp.df$name)
  AnswerTests: omnitest('unique(gdp.df$name)')
  Hint: unique(gdp.df$name)
- Class: cmd_question
  Output: |
    再來看看power.df資料中的行業別。請同學輸入：`unique(power.df$id)`
  CorrectAnswer: unique(power.df$id)
  AnswerTests: omnitest('unique(power.df$id)')
  Hint: unique(power.df$id)
- Class: text
  Output: |
    這裡的資料，一邊是英文+中文，一邊是數字或英文。所以我們先把目標
    放在英文上就好了。
- Class: cmd_question
  Output: |
    請同學輸入：`gdp.df %<>% mutate(id = strsplit(name, ".", fixed = TRUE) %>% sapply("[", 1))`
    這裡的 %<>% 表示R 會把gdp.df 放到 mutate的第一個參數，然後把輸出結果回存到
    變數 gdp.df 。這裡的動作是用 "." 來切割 gdp.df$name ，然後將"."之前的結果
    放到欄位id
  CorrectAnswer: gdp.df %<>% mutate(id = strsplit(name, ".", fixed = TRUE) %>% sapply("[",
    1))
  AnswerTests: omnitest('gdp.df %<>% mutate(id = strsplit(name, ".", fixed = TRUE)
    %>% sapply("[", 1))')
  Hint: gdp.df %<>% mutate(id = strsplit(name, ".", fixed = TRUE) %>% sapply("[",
    1))
- Class: cmd_question
  Output: |
    我們輸入：`unique(gdp.df$id)`看看整理後的結果。
  CorrectAnswer: unique(gdp.df$id)
  AnswerTests: omnitest('unique(gdp.df$id)')
  Hint: unique(gdp.df$id)
- Class: text
  Output: |
    中間混雜了一些中英文，並且有些是子類別。例如：JA、JB喊JC就是J的子類別。
- Class: cmd_question
  Output: |
    請輸入：`gdp.df2 <- filter(gdp.df, nchar(id) == 1)` 來只挑出那些
    id 為單一文字的資料
  CorrectAnswer: gdp.df2 <- filter(gdp.df, nchar(id) == 1)
  AnswerTests: omnitest('gdp.df2 <- filter(gdp.df, nchar(id) == 1)')
  Hint: gdp.df2 <- filter(gdp.df, nchar(id) == 1)
- Class: cmd_question
  Output: |
    我們輸入：`unique(gdp.df2$id)`看看整理後的結果，是不是全英文
  CorrectAnswer: unique(gdp.df2$id)
  AnswerTests: omnitest('unique(gdp.df2$id)')
  Hint: unique(gdp.df2$id)
- Class: script
  Output: |
    接著我們把目標轉到power.df。請同學利用上述所學，挑選出
    id欄位為英文的data.frame，將year轉為西元，並將結果存到
    `power.df2`中。
  Script: power-df2.R
  AnswerTests: |
    check_val("power.df2", local({
      power.df <- get("power.df", envir = globalenv())
      filter(power.df, grepl("^[A-Z]", id)) %>%
        mutate(year = year + 1911, id = gsub(".", "", id, fixed = TRUE))
    }))
- Class: text
  Output: |
    接下來，就可以用id與year來比對資料了...嗎？
- Class: cmd_question
  Output: |
    請同學輸入：`distinct(power.df2, id, name)`再檢查一下
    用電量資料裡的id所代表的意義
  CorrectAnswer: distinct(power.df2, id, name)
  AnswerTests: omnitest('distinct(power.df2, id, name)')
  Hint: distinct(power.df2, id, name)
- Class: cmd_question
  Output: |
    再請同學輸入：`distinct(gdp.df2, id, name)`再檢查一下
    國民生產毛額的資料裡的id所代表的意義
  CorrectAnswer: distinct(gdp.df2, id, name)
  AnswerTests: omnitest('distinct(gdp.df2, id, name)')
  Hint: distinct(gdp.df2, id, name)
- Class: text
  Output: 同學有沒有注意到，兩者的K，代表的意義不一致？
- Class: cmd_question
  Output: |
    這裡我們幫同學簡略地整理一個對應表，放在變數：`translation`，
    請同學看一看。這是一個多對多的對應關係。有些行業別我們不知道
    如何對應，等等就先略過。
  CorrectAnswer: translation
  AnswerTests: omnitest('translation')
  Hint: translation
- Class: cmd_question
  Output: |
    我們要先把translation展開。利用translation做一個對應表。
    請同學手動建立一個文字向量：名字就剛好是
    `c("A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K")`
    代表power.df2中的id；值是則是c(1, 2, 3, ...)，代表
    該值出現在translation中的位置。最後將結果存到變數：
    `translation.power`
  CorrectAnswer: |
    translation.power <- local({
      retval <- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 9, 10)
      names(retval) <- c("A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K")
      retval
    })
  AnswerTests: |
    check_val("translation.power", local({
      retval <- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 9, 10)
      names(retval) <- c("A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K")
      retval
    }))
  Hint: |
    translation.power <- local({
      retval <- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 9, 10)
      names(retval) <- c("A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K")
      retval
    })
- Class: cmd_question
  Output: |
    請用同樣的要領建立變數：`translation.gdp`
  CorrectAnswer: |
    translation.gdp <- local({
      translation.gdp <- c(1, 2, 3, 4, 4, 5, 6, 7, 6, 7, 8, 8, 9, 9, 10, 9, 9, 9, 9)
      names(translation.gdp) <- head(LETTERS, length(translation.gdp))
      translation.gdp
    })
  AnswerTests: |
    check_val("translation.gdp", local({
      translation.gdp <- c(1, 2, 3, 4, 4, 5, 6, 7, 6, 7, 8, 8, 9, 9, 10, 9, 9, 9, 9)
      names(translation.gdp) <- head(LETTERS, length(translation.gdp))
      translation.gdp
    }))
  Hint: |
    translation.gdp <- local({
      translation.gdp <- c(1, 2, 3, 4, 4, 5, 6, 7, 6, 7, 8, 8, 9, 9, 10, 9, 9, 9, 9)
      names(translation.gdp) <- head(LETTERS, length(translation.gdp))
      translation.gdp
    })
- Class: script
  Output: |
    接著，透過translation，我們就可以將兩邊的資料比對成一個data.frame。
    請同學挑戰看看。
  Script: power-gdp.R
  AnswerTests: "check_val(\"power.gdp\", local({\n  power.df3 <-\n    power.df2 %>%\n
    \   mutate(id2 = translation.gdp[id]) %>%\n    filter(!is.na(id2)) %>%\n    group_by(year,
    id2) %>%\n    summarise(power = sum(power), name = paste(name, collapse = \",\"))\n
    \ \n  gdp.df3 <- \n    gdp.df2 %>%\n    mutate(id2 = translation.gdp[id]) %>%\n
    \   group_by(year, id2) %>%\n    summarise(gdp = sum(gdp))\n  power.gdp <- inner_join(power.df3,
    gdp.df3, c(\"year\", \"id2\")) %>%\n    mutate(eff = gdp / power) %>%\n    as.data.frame()\n
    \ stopifnot(isTRUE(all.equal(class(power.gdp), \"data.frame\")))\n  stopifnot(isTRUE(all.equal(nrow(power.gdp),
    56)))\n  stopifnot(isTRUE(all.equal(ncol(power.gdp), 6)))\n  stopifnot(isTRUE(all.equal(colnames(power.gdp),
    c(\"year\", \"id2\", \"power\", \"name\", \"gdp\", \"eff\"))))\n  stopifnot(isTRUE(all.equal(rownames(power.gdp),
    paste(1:56))))\n  stopifnot(isTRUE(all.equal(sum(power.gdp$year), 112560)))\n
    \ stopifnot(isTRUE(all.equal(sum(power.gdp$id2), 252)))\n  stopifnot(!is.unsorted(power.gdp$year
    * 8 + power.gdp$id2))\n  stopifnot(isTRUE(all.equal(sum(power.gdp$gdp), 72840324)))\n
    \ stopifnot(power.gdp$eff == power.gdp$gdp / power.gdp$power)\n  power.gdp\n}))\n"
- Class: text
  Output: |
    恭喜同學完成比對各行業的用電資料與貢獻的國民生產毛額。
    我們接下來嘗試利用`power.gdp`來建立一些圖表看看資料說說
    故事。
