- Class: meta
  Course: DataScienceAndR
  Lesson: 02-RDataEngineer-04-Database
  Author: Wush Wu
  Type: Standard
  Organization: Taiwan R User Group
  Version: 2.3.1.1
- Class: text
  Output: |
    這次個課程將著重於如何用R 讀寫關聯式資料庫。
    **因為本次課程會操作資料庫，所以在接關功能上會有些狀況。同學請儘量一口氣完成這門課程**
- Class: text
  Output: |
    資料庫（Database）泛指能夠儲存資料的檔案櫃。
    使用者可以對檔案中的資料進行新增、擷取、更新和刪除。
- Class: text
  Output: |
    關聯式資料庫（Relational database）是近代資訊科學發展得非常成熟的一個領域。
    目前當人們提到「資料庫」時，在沒有額外說明下，通常都是指「關聯式資料庫」。
- Class: text
  Output: |
    關聯式資料庫背後的設計牽涉到一種叫「Relational Model」的數學，並且由許多資訊科學的學者發展出的理論在背後支撐。
    而關聯式資料庫設計的成功，則可以從現代資訊科學在企業的應用層面所體現。
- Class: text
  Output: |
    在資訊時代，幾乎所有日常生活中碰觸到的重要資訊，都會過經過關聯式資料庫。
    例如購票系統、會計系統、倉儲系統等等。
    關聯式資料庫的設計可以滿足廣泛的系統需求。
- Class: text
  Output: |
    而有數據的地方，就有潛在的分析需求。
    R 語言身為大數據時代最火熱的工具之一，在與各種資料庫系統的串接上，自然有一席之地。
- Class: text
  Output: |
    這次課程中，我們會描述R 語言如何透過DBI和其系列套件，操作關聯式資料庫。
    而這裡我們以SQLite這套精巧的關聯式資料庫系統為例。
- Class: text
  Output: |
    在課程開始之前先跟各位同學聲明，這次的教學並不會碰到太多資料庫的設計與效能問題。
    這些問題都是需要搭配系統的架構後，才能妥善解決的問題。
    我們也要提醒同學，如果直接用R 大量的撈取線上資料庫，是很有可能影響到資料庫的效能的。
    所以在實際操作時，建議同學最好是先知會與請教負責資料庫系統的同仁後再進行。
- Class: cmd_question
  Output: |
    請同學先安裝RSQLite套件。
    它是R 與SQLite資料庫之間的橋樑。
    專業的術語叫：「客戶端」（Client）。
  CorrectAnswer: check_then_install("RSQLite", "1.0.0")
  AnswerTests: test_package_version("RSQLite", "1.0.0")
  Hint: install.packages("RSQLite")
- Class: cmd_question
  Output: |
    請同學載入RSQLite。
  CorrectAnswer: library(RSQLite)
  AnswerTests: test_search_path("RSQLite")
  Hint: library(RSQLite)
- Class: text
  Output: |
    雖然目前市面上有許多不同的SQL 資料庫，但是這些資料庫在R 中操作起來都是非常類似的。
    R 都是透過DBI 套件所定義的函數，讓使用者操作資料庫。
- Class: text
  Output: |
    接下來的內容中，我們要帶同學操作一次SQLite 資料庫的連線、寫入資料、讀取資料、更改資料和刪除資料。
    這樣的操作是最基本的，未來在使用R 操作其他資料庫，甚至是NoSQL等外部儲存裝置時，流程也是一樣的：連線、寫入、讀取、更改和刪除。
- Class: cmd_question
  Output: |
    在跟同學繼續解釋之前，請先連接SQLite 資料庫。
    我們已經事先準備了一個SQLite資料庫的檔案，並且將路徑存在：`db_path`變數之中。
    請同學輸入：`drv <- dbDriver("SQLite")`以取得連接SQLite 資料庫的方式。
  CorrectAnswer: drv <- dbDriver("SQLite")
  AnswerTests: omnitest('drv <- dbDriver("SQLite")')
  Hint: drv <- dbDriver("SQLite")
- Class: cmd_question
  Output: |
    接著我們和SQLite 資料庫建立連線：`db <- dbConnect(drv, db_path)`。
  CorrectAnswer: db <- dbConnect(drv, db_path)
  AnswerTests: omnitest('db <- dbConnect(drv, db_path)')
  Hint: db <- dbConnect(drv, db_path)
- Class: text
  Output: |
    這裡的`db`物件，就是這個資料庫在R 中的代理人。
    若要從這個資料庫作任何動作，需要把`db`這個物件當成函數的參數之一。
    DBI的文件中會將`db`這種角色的物件記載為：`connection`。
- Class: cmd_question
  Output: |
    接著我們來嘗試把這筆數據寫入SQL 資料庫之中。
    在DBI界面中，提供了`dbWriteTable`這個函數，請大家打開這個函數的說明頁面。
  CorrectAnswer: ?dbWriteTable
  AnswerTests: any_of_exprs("?dbWriteTable", "help(dbWriteTable)", 'help("dbWriteTable")')
  Hint: ?dbWriteTable
- Class: text
  Output: |
    同學可以在說明視窗的左上角看到：`dbReadTable {DBI}`的字樣。
    這表示我們目前所操作的函數是由DBI套件所提供的功能。
    而dbReadTable和dbWriteTable的說明頁面是寫在同一頁的。
- Class: mult_question
  Output: |
    請問下列哪一個選項「不是」DBI套件`dbWriteTable`的參數？
  AnswerChoices: conn;name;value;overwrite
  CorrectAnswer: overwrite
  AnswerTests: omnitest(correctVal = "overwrite")
- Class: cmd_question
  Output: |
    因為`db`是由RSQLite所提供的資料庫代理人（當初的`drv`代表的是`dbDriver("SQLite")`)，除了DBI的`dbWriteTable`之外，我們還有額外的參數可以使用。
    請同學輸入：`help.search("dbWriteTable")`
  CorrectAnswer: help.search("dbWriteTable")
  AnswerTests: omnitest('help.search("dbWriteTable")')
  Hint: help.search("dbWriteTable")
- Class: cmd_question
  Output: |
    R 會列出至少兩個dbWriteTable的說明，且其中一個是來自RSQLite。
    在Rstudio下，同學只要用滑鼠去點選連結即可。
    但是限於swirl環境，這裡需要同學輸入以下指令（或是`skip()`）：`help("dbWriteTable,SQLiteConnection,character,data.frame-method")`。
    使用R 原生環境的同學也是利用上述指令查詢RSQLite提供的dbWriteTable。
  CorrectAnswer: help("dbWriteTable,SQLiteConnection,character,data.frame-method")
  AnswerTests: omnitest('help("dbWriteTable,SQLiteConnection,character,data.frame-method")')
  Hint: help("dbWriteTable,SQLiteConnection,character,data.frame-method")
- Class: mult_question
  Output: |
    此時的說明頁面左上角，會註明這份文件是來自RSQLite套件。
    請同學參考文件內容後，回答以下問題：`overwrite`是不是dbWRiteTable的參數呢？
  AnswerChoices: yes;no
  CorrectAnswer: 'yes'
  AnswerTests: omnitest(correctVal="yes")
- Class: text
  Output: |
    這是R 在處理SQL 資料庫的設計。
    如果使用者只有操作到DBI的dbWriteTable提供的功能，那未來相同的程式碼運作在其他的資料庫系統時，不需要太大的修改即可運作。
    但是如果是用了RSQLite提供的功能（如overwrite），那在切換資料庫時，就需確認新的資料庫的R 套件是否提供類似的功能。
- Class: text
  Output: |
    在解釋`dbWriteTable`之前，我們要先對資料庫系統有一點簡單的認知。
    資料庫在處理數據時，會將數據放在一個又一個的表格中。
    這和R 會把一個data.frame存放到對應的變數之中是相似的。
- Class: text
  Output: |
    回到`DBI::dbWriteTable(connection, name, value, ...)`的說明，R 會嘗試透過connection物件，將value的data.frame寫入到名稱為name的表格中。
- Class: cmd_question
  Output: |
    舉例來說，若我們想要將`lvr_land`這個記載實價登錄資訊的表格，寫到SQLite資料庫中。
    請同學利用指令：`head(lvr_land)`看一下這個資料集。
  CorrectAnswer: head(lvr_land)
  AnswerTests: omnitest("head(lvr_land)")
  Hint: head(lvr_land)
- Class: text
  Output: |
    欄位名稱很清楚的註明每個欄位的數據意義。
- Class: cmd_question
  Output: |
    由於在Windows上的RSQLite 1.0.0版本之後的套件有bug(已經於2019年1月時候修正)，
    導致中文的欄位名稱會發生錯誤。因此我們將`lvr_land`的欄位名稱改為英文。
    請同學輸入：`colnames(lvr_land) <- lvr_land.names`
  CorrectAnswer: colnames(lvr_land) <- lvr_land.names
  AnswerTests: omnitest('colnames(lvr_land) <- lvr_land.names')
  Hint: colnames(lvr_land) <- lvr_land.names
- Class: cmd_question
  Output: |
    接著，我們透過`dbWriteTable`將實價登錄資料寫入資料庫中。
    請同學輸入：`dbWriteTable(db, "lvr_land2", lvr_land)`。
  CorrectAnswer: dbWriteTable(db, "lvr_land2", lvr_land)
  AnswerTests: check_lvr_land(db)
  Hint: dbWriteTable(db, "lvr_land2", lvr_land)
- Class: text
  Output: |
    這樣的動作，就類似在R 中執行：`lvr_land2 <- <lvr_land的值>`，差別只在於lvr_land2這個名字是一個SQLite資料庫的表格。
- Class: text
  Output: |
    R 大部分的資料庫套件，在`dbWriteTable`函數中都會提供`append`和`overwrite`兩個參數。
- Class: text
  Output: |
    `overwrite = TRUE` 時，R 會自動把撞名的表格刪除，並且寫入新的資料。
    如果是`overwrite = FALSE`時撞名，R 就會出錯。
    這個部分若是讓同學測試的話，swirl會跳掉，所以就只能先帶過了。
- Class: text
  Output: |
    `append = TRUE`時，R 會把我們要寫入的資料，接在撞名的表格之下。
    這等介紹完`dbReadTable`之後，我們再試試。
- Class: cmd_question
  Output: |
    接下來，透過`dbReadTable`來從表格中取出資料。
    這個指令只需要兩個參數：`connection`和`name`。
    請同學輸入：`dbReadTable(db, "lvr_land2")`，就可以看到剛剛的數據。
  CorrectAnswer: dbReadTable(db, "lvr_land2")
  AnswerTests: omnitest('dbReadTable(db, "lvr_land2")')
  Hint: dbReadTable(db, "lvr_land2")
- Class: cmd_question
  Output: |
    我們可以再寫入一次`lvr_land`，並且設定`append = TRUE`。
    請同學試試看輸入：`dbWriteTable(db, "lvr_land2", lvr_land, append = TRUE)`
  CorrectAnswer: dbWriteTable(db, "lvr_land2", lvr_land, append = TRUE)
  AnswerTests: omnitest('dbWriteTable(db, "lvr_land2", lvr_land, append = TRUE)')
  Hint: dbWriteTable(db, "lvr_land2", lvr_land, append = TRUE)
- Class: cmd_question
  Output: |
    請再次執行`dbReadTable(db, "lvr_land2")`，讀取"lvr_land2"表格看看。
  CorrectAnswer: dbReadTable(db, "lvr_land2")
  AnswerTests: omnitest('dbReadTable(db, "lvr_land2")')
  Hint: dbReadTable(db, "lvr_land2")
- Class: text
  Output: |
    這次應該會看到38或57筆資料（因為lvr_land總共有19筆資料，寫入兩次後會有38筆，三次則會有57筆），
    如果不幸需要接關的同學可能看到更多筆...
- Class: cmd_question
  Output: |
    `dbListTables(db)`可以列出目前已經存在於資料庫的表格。
    請同學試試看。
  CorrectAnswer: dbListTables(db)
  AnswerTests: omnitest('dbListTables(db)')
  Hint: dbListTables(db)
- Class: cmd_question
  Output: |
    請試著用`iris2 <- dbReadTable(db, "iris")`來讀出剛剛看到的`iris`表格，並存入變數`iris2`。
    這是我是前先將R 內建的iris資料集寫入資料庫後所產生的表格。
  CorrectAnswer: iris2 <- dbReadTable(db, "iris")
  AnswerTests: omnitest('iris2 <- dbReadTable(db, "iris")')
  Hint: iris2 <- dbReadTable(db, "iris")
- Class: cmd_question
  Output: |
    如同在RDataMining-03中看到jsonlite的vignette，我們可以用`all.equal(iris, iris2)`來比較看看兩者是不是一模一樣。
  CorrectAnswer: all.equal(iris, iris2)
  AnswerTests: omnitest('all.equal(iris, iris2)')
  Hint: all.equal(iris, iris2)
- Class: text
  Output: |
    同學會看到：`"Component “Species”: 'current' is not a factor"`的字樣，這表示當我們從資料庫中將iris拿出來後，Species的型態改變了。
- Class: text
  Output: |
    型態改變這件事情，其實是可大可小的。
    在大部分的狀況下，例如建立統計模型、製作圖表、或是factor字串（character）的互換並不會帶來太大的困擾。
    但是在某些很不常見的狀況下（如`strsplit`在遇到factor的時候會出錯），可能會導致程式出錯。
    這是很討厭的。
- Class: text
  Output: |
    我有開發過大型R 的應用系統的經驗，而像這類型態不符的地方，往往會導致系統產生無法預期的結果。
    舉例來說，當我嘗試把資料處理的流程搬入資料庫後，某些原本可以運作的程式碼就變成無法運作了（就是`strsplit`）。
- Class: text
  Output: |
    大部分的R 使用者，大概都不需要管到這件事情。
    但是如果有一天R 不聽你話的時候，請記得檢查上述提及的這些小地方。
- Class: text
  Output: |
    以上講解的`dbReadTable`和`dbWriteTable`，都是一次將所有資料倒進去和拿出來的方法，雖然方便，但當數據量很大的時候，一次可能只需要一部分的資料。
    進階的使用者可能需要更多關聯式資料庫所提供的功能。
- Class: cmd_question
  Output: |
    DBI界面中，我們可以利用`dbGetQuery`和`dbSendQuery`來執行SQL語句。
    SQL是操作關聯式資料庫的必學工具，也是資料科學家必備的工具之一。
    請同學執行：`dbGetQuery(db, "SELECT * FROM iris WHERE species = \"virginica\"")`
  CorrectAnswer: dbGetQuery(db, "SELECT * FROM iris WHERE species = \"virginica\"")
  AnswerTests: omnitest('dbGetQuery(db, "SELECT * FROM iris WHERE species = \\"virginica\\"")')
  Hint: dbGetQuery(db, "SELECT * FROM iris WHERE species = \"virginica\"")
- Class: text
  Output: |
    剛剛的範例中，`"SELECT * FROM iris WHERE species = \"virtinica\""`是一段SQL expression。
    而`dbGetQuery`會解析這樣的SQL expression，並且依照指令進行資料庫的操作後，再將結果直接回傳給R 。
- Class: cmd_question
  Output: |
    `dbSendQuery`函數則會先將結果儲存於Result物件中，再由使用者一段一段的取出。
    請同學試著執行：`rs <- dbSendQuery(db, "SELECT * FROM iris")`。
  CorrectAnswer: rs <- dbSendQuery(db, "SELECT * FROM iris")
  AnswerTests: omnitest('rs <- dbSendQuery(db, "SELECT * FROM iris")')
  Hint: rs <- dbSendQuery(db, "SELECT * FROM iris")
- Class: cmd_question
  Output: |
    上一關所拿到的`rs`物件，就是整個資料集的「代理」。
    我們可以利用`fetch`方法，一次拿一點資料出來。
    請同學試試看：`fetch(rs, 1)`。
  CorrectAnswer: fetch(rs, 1)
  AnswerTests: omnitest('fetch(rs, 1)')
  Hint: fetch(rs, 1)
- Class: cmd_question
  Output: |
    請同學再試一次：`fetch(rs, 1)`（可以按一下 ↑ ，正常安裝的R 會顯示上一個輸入）
  CorrectAnswer: fetch(rs, 1)
  AnswerTests: omnitest('fetch(rs, 1)')
  Hint: fetch(rs, 1)
- Class: text
  Output: |
    同學應該會注意到，兩次的結果是不同的。
    這是因為在第一次`dbSendQuery`指令完成之後，R 和資料庫就把結果暫存到某個地方，並且將代理物件(也就是`rs`)回傳。
    之後每次執行`fetch`指令時，R 就會「依照順序」把結果一個又一個的回傳給使用者。
    如果使用者每次想多拿一些資料，則可以更改第二個參數，如：`fetch(rs, 100)`一次取出100筆資料。
- Class: cmd_question
  Output: |
    當我們不需要再使用`rs`物件時，就刪除它：`dbClearResult(rs)`。
    請同學試試看。
  CorrectAnswer: dbClearResult(rs)
  AnswerTests: omnitest('dbClearResult(rs)')
  Hint: dbClearResult(rs)
- Class: text
  Output: |
    `dbSendQuery`和`fetch`的技巧在使用R 處理「大量資料」，是非常有用的。
    尤其是當資料量「超過記憶體」時，運用資料庫可以很有效率地優化硬碟處理資料的效能。
    此時，如果我們的演算法不需要一次看到所有的資料，那`dbSendQuery`和`fetch`就非常有用，它們可以避免我們發生滑鼠不能移動的悲劇。
- Class: text
  Output: |
    上述的課程中，我們並沒有講解SQL expression。
    同學如果有興趣的話，可以再找SQL相關的資料學習。
    這部份的細節，留待後續`dplyr`套件的系列課程中，再跟同學介紹。
    我們這裡想要強調的是所有對資料庫的基礎操作，以及DBI所提供一些輔助函數，例如：`dbGetQuery`、`dbSendQuery`等。
- Class: text
  Output: |
    最後，我們示範資料庫的transaction功能。
    這在處理資料時，也是非常重要的操作步驟。
- Class: text
  Output: |
    當我們在運用外部資源（如資料庫、如檔案系統）處理資料時，最害怕的狀況是被意外中斷。
    舉例來說，網路可能剛好斷線、硬碟突然壞軌、或是發生意想不到的狀況。
    這時候除了幫工程師買乖乖之外，實務上其實有一些技巧可以避免意外帶來的困擾。
- Class: text
  Output: |
    意外對我們最大的困擾並不是工作中斷。
    畢竟作分析的工作，畫畫的時候R 掛掉了，就... 重新開R再跑一遍就好了。
    但是當我們正在寫入資料庫時，意外的中斷就會帶來以下的困擾。
- Class: text
  Output: |
    在排除意外的原因繼續工作之前，我們需要先知道目前資料庫，是處於「還未寫入」、「寫到一半」或是「寫入完畢」中哪一個狀態。
    在「還未寫入」的狀況下，我們只要重新執行程式即可。
    而「寫入完畢」的話就更棒了，可以繼續後續的工作。
    但是若是「寫到一半」的狀態，要接著工作就會非常麻煩，甚至可能還需要改動程式碼。
- Class: text
  Output: |
    Transaction是一種保證資料庫的狀態一定是「還未寫入」或是「寫入完畢」的機制。
- Class: cmd_question
  Output: |
    在進行接下來關於Transaction的練習之前，我們先重新連線。
    請同學先中斷連線，輸入：`dbDisconnect(db)`。
  CorrectAnswer: dbDisconnect(db)
  AnswerTests: omnitest('dbDisconnect(db)')
  Hint: dbDisconnect(db)
- Class: cmd_question
  Output: |
    請同學再次輸入：db <- dbConnect(drv, db_path)`。
  CorrectAnswer: db <- dbConnect(drv, db_path)
  AnswerTests: omnitest('db <- dbConnect(drv, db_path)')
  Hint: db <- dbConnect(drv, db_path)
- Class: cmd_question
  Output: |
    在R 中，我們可以利用`dbBegin(db)`來開啟一個Transaction。
    請同學試試看。
  CorrectAnswer: dbBegin(db)
  AnswerTests: omnitest('dbBegin(db)')
  Hint: dbBegin(db)
- Class: cmd_question
  Output: |
    接著，讓我們利用`dbRemoveTable(db, "CO2")`來刪除"CO2"表格。
  CorrectAnswer: dbRemoveTable(db, "CO2")
  AnswerTests: omnitest('dbRemoveTable(db, "CO2")')
  Hint: dbRemoveTable(db, "CO2")
- Class: cmd_question
  Output: |
    請同學用`dbListTables(db)`來檢查"CO2"表格是不是已經消失在表格清單之中。
  CorrectAnswer: dbListTables(db)
  AnswerTests: omnitest('dbListTables(db)')
  Hint: dbListTables(db)
- Class: cmd_question
  Output: |
    請同學輸入`dbDisconnect(db)`，模擬當意外發生時與資料庫的連線中斷的狀況。
  CorrectAnswer: dbDisconnect(db)
  AnswerTests: omnitest('dbDisconnect(db)')
  Hint: dbDisconnect(db)
- Class: cmd_question
  Output: |
    請同學輸入`db <- dbConnect(drv, db_path)`重新連接資料庫。
  CorrectAnswer: db <- dbConnect(drv, db_path)
  AnswerTests: omnitest('db <- dbConnect(drv, db_path)')
  Hint: db <- dbConnect(drv, db_path)
- Class: cmd_question
  Output: |
    請同學用`dbListTables(db)`來檢查，"CO2"表格是不是又重出江湖了呢？
  CorrectAnswer: dbListTables(db)
  AnswerTests: omnitest('dbListTables(db)')
  Hint: dbListTables(db)
- Class: text
  Output: |
    除了中斷連線，我們也可以主動使用`dbRollback(db)`指令，將資料庫的狀態復原至我們執行`dbBegin(db)`的時間點。
- Class: cmd_question
  Output: |
    再請同學輸入：`dbBegin(db)`。
  CorrectAnswer: dbBegin(db)
  AnswerTests: omnitest('dbBegin(db)')
  Hint: dbBegin(db)
- Class: cmd_question
  Output: |
    接著，讓我們利用`dbRemoveTable(db, "CO2")`再刪除"CO2"表格一次。
  CorrectAnswer: dbRemoveTable(db, "CO2")
  AnswerTests: omnitest('dbRemoveTable(db, "CO2")')
  Hint: dbRemoveTable(db, "CO2")
- Class: cmd_question
  Output: |
    這次請輸入`dbCommit(db)`。
  CorrectAnswer: dbCommit(db)
  AnswerTests: omnitest('dbCommit(db)')
  Hint: dbCommit(db)
- Class: cmd_question
  Output: |
    請同學用`dbListTables(db)`來檢查"CO2"表格是不是確實消失了？
  CorrectAnswer: dbListTables(db)
  AnswerTests: omnitest('dbListTables(db)')
  Hint: dbListTables(db)
- Class: text
  Output: |
    在這之後，就算我們斷線重連，"CO2"表格也不會回來了。
- Class: text
  Output: |
    總而言之，當`dbBegin(db)`開始運行之後，所有的變更都要等到執行`dbCommit(db)`後才會生效。
    中間只要發生任何狀況：無論是使用者主動`dbRollback(db)`，或是發生意外導致斷線，資料庫都會自動復原至我們執行`dbBegin(db)`時的狀態。
    這個方法在寫入大量數據時，也是很重要的技巧，可以保證我們的「資料正確性」。
- Class: text
  Output: |
    資料庫還有許多處理資料的技術與手法，例如JOIN等相關技術。
    但是這都牽涉到SQL語法的學習，而且各家資料庫系統在這部份的語法也會略有差異，所以本次課程僅著重於R 與資料庫之間的簡易操作以及基礎概念。
- Class: script
  Output: |
    最後還是請各位同學利用以上學習的內容，操作一次資料庫系統。
    請同學在完成之後存檔，並輸入`submit()`來檢查結果是否符合預期。
    如果同學在檔案中看到亂碼，請使用Rstudio 左上角的File -> Reopen
  Script: RDataEngineer-04-HW.R
  AnswerTests: rdataengineer_04_hw_test()

