- Class: meta
  Course: DataScienceAndR
  Lesson: 02-RDataEngineer-05-Data-Manipulation
  Author: Wush Wu and Cheng-Yu Lin
  Type: Standard
  Organization: Taiwan R User Group
  Version: 2.3.1.1
- Class: text
  Output: |
    前半段的課程，大部分著重於從資料中萃取出資訊，並且整理成一個data.frame（結構化）。
    這門課程則是要開始討論，當資訊已經被結構化之後，我們要如何整理結構化的資料。
- Class: text
  Output: |
    R 有許多解決這類問題的函數，例如：`melt`、`subset`等等，族繁不及備載。
    這些函數的名稱不容易記憶，而且效能並不是很好。
- Class: text
  Output: |
    dplyr套件是Hadley Wickham和Romain Francois在2014上架的一個套件，是目前我認為在R 中做資料整理上最完善的套件之一。
    dplyr提供了直觀的函數，並且能夠和SQL expression做對應，效能也被Romain透過C++進行優化過，上述的優勢讓我決定跳過傳統R 整理資料的工具，直接教大家dplyr。
- Class: cmd_question
  Output: |
    請大家先安裝`dplyr`套件。
  CorrectAnswer: check_then_install("dplyr", "0.4.3")
  AnswerTests: test_package_version("dplyr", "0.4.3")
  Hint: check_then_install("dplyr", "0.4.3")
- Class: cmd_question
  Output: |
    接著請大家載入dplyr套件。
  CorrectAnswer: library(dplyr)
  AnswerTests: test_search_path("dplyr")
  Hint: library(dplyr)
- Class: cmd_question
  Output: |
    請同學輸入學套件的起手式：`vignette(package = "dplyr")`。
  CorrectAnswer: vignette(package = "dplyr")
  AnswerTests: omnitest('vignette(package = "dplyr")')
  Hint: vignette(package = "dplyr")
- Class: text
  Output: |
    Hadley等人都是開發R 套件界的大大，他們對vignette是非常重視的，所以我們會看到許多vignette。
    說實話，我個人寫的dplyr套件的介紹絕對也不會比Hadley大大他們寫的精彩。
    不過透過swirl的好處，就是我們可以把整個dplyr的功能都經歷過一遍。
- Class: cmd_question
  Output: |
    請同學執行`vignette("introduction", package = "dplyr")`，打開Introduction。
  CorrectAnswer: vignette("introduction", package = "dplyr")
  AnswerTests: omnitest('vignette("introduction", package = "dplyr")')
  Hint: vignette("introduction", package = "dplyr")
- Class: cmd_question
  Output: |
    簡單起見，我們直接跟著vignette，拿`nycflights13`中的資料集`flights`做練習。
    請同學先安裝`nycflights13`套件。
  CorrectAnswer: check_then_install("nycflights13", "0.1")
  AnswerTests: test_package_version("nycflights13", "0.1")
  Hint: install.packages("nycflights13")
- Class: cmd_question
  Output: |
    接著載入`nycflights13`套件。
  CorrectAnswer: library(nycflights13)
  AnswerTests: test_search_path("nycflights13")
  Hint: library(nycflights13)
- Class: text
  Output: |
    這個套件提供的flights資料集合，內容為所有於2013年在紐約起降的飛機資料。
- Class: cmd_question
  Output: |
    Vignette中宣稱flights共有336776筆資料。
    我們進行驗證一下，也順便讓同學複習data.frame的操作。
    請同學用指令查詢flights共有多少資料。
  CorrectAnswer: nrow(flights)
  AnswerTests: omnitest(correctVal = nrow(flights))
  Hint: nrow(flights)
- Class: text
  Output: |
    在dplyr中，處理data.frame的函數共有：`filter`、`slice`、`arrange`、`select`、`distinct`、`mutate`、`summarise`和`sample_n`。
    接下來的課程中，我們一邊操作，一邊講解。
- Class: cmd_question
  Output: |
    `filter`的目的是用來做列方向的過濾，所以經過`filter`處理後，資料的個數（`nrow`）會下降。
    `filter`函數的用法為，第一個參數放我們要處理的data.frame，後面接著不同的過濾條件。
    例如：`filter(flights, month == 1, day == 1)`，請同學試試看。
  CorrectAnswer: filter(flights, month == 1, day == 1)
  AnswerTests: omnitest('filter(flights, month == 1, day == 1)')
  Hint: filter(flights, month == 1, day == 1)
- Class: text
  Output: |
    同學應該會注意到，輸出結果中`month`和`day`都是1 了。
    因為`filter`會將資料一筆一筆的對後面的語句（`month == 1`和`day == 1`）做檢查。
    R 在解析這些語句時，會自動將這些變數對應到`flights`的欄位。
    所以在`filter`中的`month`就等同於`flights$month`，`day`就等同於`flights$day`。
- Class: text
  Output: |
    熟悉SQL expression的同學請注意，`filter`就是SQL中的`WHERE`。
- Class: script
  Output: |
    如果要使用RBasic系列所使用的語法，要如何得到同樣的結果呢？
    請同學試著寫寫看。
    提示：兩個布林比較和一個`[`。
    這題請在檔案：RDataEngineer-05-01.R中作答，完成後請存檔並切換到console中輸入：submit()。
  Script: RDataEngineer-05-01.R
  AnswerTests: test_equal(answer01, flights[flights$month == 1 & flights$day == 1,])
- Class: text
  Output: |
    為了降低難度，我們在scripts中讓大家是一步一步的做操作。
    實務上，熟悉R 的使用者會直接寫一行：`flights[flights$month == 1 & flights$day == 1,]`，這是一種程式碼的壓縮。
- Class: text
  Output: |
    程式碼的壓縮，讓使用者可以減少打字及減少設定暫存變數，如剛剛寫的`month_is_1`、`day_is_1`和`is_target`等等。
    但是即使如此，dplyr提供的`filter`可以用更簡潔程式碼達到一樣的效果。
    背後的原因就在於`flights$month`和`flights$day`的`flights`被省略了。
- Class: text
  Output: |
    一般來說，`filter`的第一個參數，代表著要做處理的data.frame，而後面的參數皆都為條件。
    每個條件就是一個expression，並且輸出布林向量。
    `filter`則只會回傳那些滿足所有條件的資料。
- Class: text
  Output: |
    這堂課程介紹的dplyr的函數，都具有一樣的性質：第一個參數是要處理的data.frame，而其餘的參數是不同的expression，且這些expression中的變數名稱都會優先對應到data.frame
    中的欄位。
- Class: cmd_question
  Output: |
    請同學試著從`flights`中找出`flights$month`為 1，`flights$day`為2的資料。
  CorrectAnswer: filter(flights, month == 1, day == 2)
  AnswerTests: val_is(filter(flights, month == 1, day == 2))
  Hint: filter(flights, month == 1, day == 2)
- Class: text
  Output: |
    filter也會自動過濾掉結果為 NA 的條件。
    在下一個題目，同學可以趁機摸索看看。
- Class: script
  Output: |
    請問同學，在2013年的紐約，共有多少班次的飛機起飛延誤呢？(`dep_delay > 0`)
    請同學在視窗開啟的Script中編寫，並且在完成後輸入`submit()`。
  Script: RDataEngineer-05-02.R
  AnswerTests: test_equal(answer02, nrow(filter(flights, dep_delay > 0)))
- Class: text
  Output: |
    上一題的答案也是可以做程式碼的壓縮的。
    同學可以先用`filter(flights, dep_delay > 0)`篩選出資料集之後，直接把結果的值傳到`nrow`的第一個參數，也就是：`nrow(filter(flights, dep_delay > 0))`。
- Class: cmd_question
  Output: |
    有時候我們希望找出符合特定條件的文字。
    舉例來說，如果我們要找出`tailnum`中包含有`"AA"`的文字，要怎麼做呢？
    R 內建有一個`grepl`的函數可以解決這個問題。
    請同學先輸入`?grepl`打開它的說明文件。
  CorrectAnswer: ?grepl
  AnswerTests: any_of_exprs("?grepl", "help(grepl)", 'help("grepl")')
  Hint: ?grepl
- Class: text
  Output: |
    `grepl`的參數很多，但是這裡我們只要學三個參數：`pattern`、`x`和、`fixed`。
    第一個參數`pattern`，代表的是我們要找的模式。
    舉例來說，如果我們要找`"AA"`，pattern就會是`"AA"`。
    但是如果是在`fixed = FALSE`狀態下，R 會使用「正則表示式」（Regular Expression）來處理`pattern`，有時候會有預期外的結果。
    這部份在同學學會正則表示式之前，都請先設定`fixed = TRUE`比較單純。
    `x`就是我們要搜尋文字。
    在這範例中，就是`flights$tailnum`。
- Class: mult_question
  Output: |
    我們想輸出的程式碼是：`filter(flights, grepl(pattern = <1>, x = <2>, fixed = TRUE))`，
    這裡透過適當的設定`grepl`的參數，就可以獲得我們想要的比對結果，也就是「tailnum中是不是有包含`"AA"`這樣的文字」的結果。
    而`filter`再利用這樣的結果對資料做篩選。
    請問同學，<1>應該要填寫什麼呢？
  AnswerChoices: |
    "AA";AA;flights;flights$tailnum
  CorrectAnswer: '"AA"'
  AnswerTests: omnitest(correctVal = '"AA"')
- Class: mult_question
  Output: |
    我們想輸出的程式碼是：`filter(flights, grepl(pattern = <1>, x = <2>, fixed = TRUE))`。
    請問同學，<2>應該要填寫什麼？
  AnswerChoices: |
    "AA";AA;flights;flights$tailnum
  CorrectAnswer: flights$tailnum
  AnswerTests: omnitest(correctVal = 'flights$tailnum')
- Class: mult_question
  Output: |
    再請問同學，`filter(flights, grepl(pattern = "AA", x = tailnum, fixed = TRUE))`是不是也成立呢？
  AnswerChoices: Yes;No
  CorrectAnswer: 'Yes'
  AnswerTests: omnitest(correctVal = "Yes")
- Class: cmd_question
  Output: |
    最後，請同學試試看：`filter(flights, grepl(pattern = "AA", x = tailnum, fixed = TRUE))`。
  CorrectAnswer: filter(flights, grepl(pattern = "AA", x = tailnum, fixed = TRUE))
  AnswerTests: omnitest('filter(flights, grepl(pattern = "AA", x = tailnum, fixed
    = TRUE))')
  Hint: filter(flights, grepl(pattern = "AA", x = tailnum, fixed = TRUE))
- Class: text
  Output: |
    針對`filter`已經介紹得差不多了。接下來我們會介紹`slice`。
    `slice`很單純，`slice(flights, 1:6)`就等價於`flights[1:6,]`。
- Class: cmd_question
  Output: |
    讓我們直接進入練習吧!「用肌肉記憶」。
    請同學選出`flights`的第10000 到 第20000筆資料。
  CorrectAnswer: slice(flights, 10000:20000)
  AnswerTests: val_is(slice(flights, 10000:20000))
  Hint: slice(flights, 10000:20000)
- Class: cmd_question
  Output: |
    接下來，我們練習`arrange`。
    `arrange`會把data.frame的資料，根據後面的expression做排序。
    請同學試試看：`arrange(flights, month, day, dep_time)`。
    給熟悉SQL的同學，`arrange`的用法很類似SQL的`ORDER BY`。
  CorrectAnswer: arrange(flights, month, day, dep_time)
  AnswerTests: omnitest('arrange(flights, month, day, dep_time)')
  Hint: arrange(flights, month, day, dep_time)
- Class: text
  Output: |
    我們仔細觀察上一題的輸出。
    `arrange`會先比較`month`的值，當`month`平手時就比較`day`的值，以此類推。
    所以我們看到的輸出中，最前面的結果就是`month`、`day`皆為最小的資料中，`dep_time`值最小的資料。
- Class: mult_question
  Output: |
    所以我們能不能根據上面的結果判斷：`dep_time`的最小值是517呢？（第一列的dep_time）
  AnswerChoices: Yes;No
  CorrectAnswer: 'No'
  AnswerTests: omnitest(correctVal = "No")
- Class: cmd_question
  Output: |
    我們是不能確定這件事情的，因為有些資料可能有更小的`dep_time`，但是他們的`day`和`month`太大，所以被排到後面去了。
    我們來找找看`dep_time`的最小值吧。
    請同學輸入：`min(flights$dep_time)`。
  CorrectAnswer: min(flights$dep_time)
  AnswerTests: omnitest('min(flights$dep_time)')
  Hint: min(flights$dep_time)
- Class: cmd_question
  Output: |
    我們注意到dep_time的資料有missing data。
    導致上一題的輸出為`NA`。
    我們要怎麼忽略`NA`呢？
    請同學試試看：`min(flights$dep_time, na.rm = TRUE)`。
  CorrectAnswer: min(flights$dep_time, na.rm = TRUE)
  AnswerTests: omnitest('min(flights$dep_time, na.rm = TRUE)')
  Hint: min(flights$dep_time, na.rm = TRUE)
- Class: cmd_question
  Output: |
    我們也可以把比較的順序從由小到大改成由大到小，只要加上`desc`就行了。
    舉例來說：`arrange(flights, desc(month), desc(day), desc(dep_time))`，請同學試試看。
  CorrectAnswer: arrange(flights, desc(month), desc(day), desc(dep_time))
  AnswerTests: omnitest('arrange(flights, desc(month), desc(day), desc(dep_time))')
  Hint: arrange(flights, desc(month), desc(day), desc(dep_time))
- Class: cmd_question
  Output: |
    接下來我們來介紹`select`。
    通常一個很大的data.frame中，我們一次只會對少數幾欄資料有興趣，`select`可以讓我們挑出我們有興趣的欄位。
    請同學試試看：`select(flights, year, month, day)`。
    給熟SQL的同學，`select`就是SQL中的`SELECT`。
  CorrectAnswer: select(flights, year, month, day)
  AnswerTests: omnitest('select(flights, year, month, day)')
  Hint: select(flights, year, month, day)
- Class: cmd_question
  Output: |
    我們先檢查`flights`的欄位名稱。
    請同學複習一下之前所學的data.frame的操作。
  CorrectAnswer: colnames(flights)
  AnswerTests: omnitest(correctVal = colnames(flights))
  Hint: colnames(flights)
- Class: cmd_question
  Output: |
    我們也可以用`select(flights, year:day)`來選取`year`和`day`之間的欄位。
    請同學試試看。
  CorrectAnswer: select(flights, year:day)
  AnswerTests: omnitest('select(flights, year:day)')
  Hint: select(flights, year:day)
- Class: cmd_question
  Output: |
    如果是要反面選取，剃除掉`year`到`day`之間的欄位，只要使用：`select(flights, -(year:day))`。
    請同學試試看。
  CorrectAnswer: select(flights, -(year:day))
  AnswerTests: omnitest('select(flights, -(year:day))')
  Hint: select(flights, -(year:day))
- Class: script
  Output: |
    進行到這裡，出一個小練習給同學。
    請同學選出`flights`中`dep_time`為NA的資料，並只挑出`year`、`month`和`day`這三欄。
    請同學在視窗開啟的Script中編寫，並且在完成後輸入`submit()`。
  Script: RDataEngineer-05-03.R
  AnswerTests: test_equal(answer03, select(filter(flights, is.na(dep_time)), year:day))
- Class: text
  Output: |
    上一題的目的是想看看dep_time為"NA"是不是有異常的模式。
    例如，都聚集在某一天。
    實務上在做資料分析時，常常需要對自己資料的正確性保持懷疑，因此常常要篩選出資料來做觀察確認。
    此時，是否熟練的運用dplyr的函數就會影響到我們的工作效率。
- Class: text
  Output: |
    接著我們介紹`distinct`。
    它可以挑出後續多個expression的組合中，不重複的部份。
    所以`distinct`能用來回答「資料有多少類」等問題。
    給熟SQL的同學，distinct就是SQL的`DISTINCT`。
- Class: cmd_question
  Output: |
    請同學試試看：`distinct(select(flights, year:day))`。
    一年有365天，是不是每天都有資料呢？
  CorrectAnswer: distinct(select(flights, year:day))
  AnswerTests: omnitest('distinct(select(flights, year:day))')
  Hint: distinct(select(flights, year:day))
- Class: cmd_question
  Output: |
    當我們要更改，或是新增欄位時，就可以使用`mutate`這個欄位了。
    舉例來說，如果我們要新增一個欄位`gain`，它是拿arr_delay扣掉dep_delay，代表飛機停留在紐約機場待的時間比原本簡短多少。
    此時，我們可以用：`mutate(flights, gain = arr_delay - dep_delay)`。
  CorrectAnswer: mutate(flights, gain = arr_delay - dep_delay)
  AnswerTests: omnitest('mutate(flights, gain = arr_delay - dep_delay)')
  Hint: mutate(flights, gain = arr_delay - dep_delay)
- Class: text
  Output: |
    `mutate`的功能就類似SQL的UPDATE，但因為可以新增欄位，所以更為廣泛。
    在`mutate`中，後面的expression可以使用前面expression所新增的欄。
- Class: text
  Output: |
    最後我們介紹`summarise`，它會根據給定的函數，計算出單一的值。
    舉例來說：`max`、`min`都可以是這樣的函數，但是`range`就會出問題。
    因為`max`和`min`的輸出長度為1 ，但是`range`的輸出長度為2。
- Class: cmd_question
  Output: |
    請同學輸入`summarise(flights, mean(dep_delay, na.rm = TRUE))`來計算平均的誤點時間。
  CorrectAnswer: summarise(flights, mean(dep_delay, na.rm = TRUE))
  AnswerTests: omnitest('summarise(flights, mean(dep_delay, na.rm = TRUE))')
  Hint: summarise(flights, mean(dep_delay, na.rm = TRUE))
- Class: cmd_question
  Output: |
    我們也可以透過`sample_n`或`sample_frac`從`flights`中抽出資料。
    這個方法在資料很大，且電腦又不夠力的狀況下很有用。
    舉例來說，`sample_n(flights, 10)`會從數據中抽10筆資料。
    請同學試試看。
  CorrectAnswer: sample_n(flights, 10)
  AnswerTests: omnitest('sample_n(flights, 10)')
  Hint: sample_n(flights, 10)
- Class: cmd_question
  Output: |
    也請同學試試看：`sample_frac(flights, 0.01)`。
  CorrectAnswer: sample_frac(flights, 0.01)
  AnswerTests: omnitest('sample_frac(flights, 0.01)')
  Hint: sample_frac(flights, 0.01)
- Class: text
  Output: |
    當需要取後放回的隨機抽樣時，可以下參數：`replace = TRUE`。
    而當希望機率不相等時，可以把機率的比率送到`weight`這個參數。
- Class: text
  Output: |
    在認識這些主要的dplyr功能後，同學是不是有注意到，第一個參數總是我們要處理的data.frame呢？
- Class: text
  Output: |
    本堂課第二個要點是，我們可以在後面的參數，後續的expression中省略data.frame的變數名稱。
- Class: text
  Output: |
    而第三個要點我們前面沒有強調，就是每次產生的data.frame都是新的，我們並沒有更動原本的`flights`。
- Class: text
  Output: |
    有了這些工具之後，就可以組合出複雜的邏輯。
- Class: script
  Output: |
    這裡請同學做一些小練習。
    請在完成之後存檔，並輸入`submit()`來檢查結果是否符合預期。
    如果同學在檔案中看到亂碼，請使用Rstudio 左上角的File -> Reopen。
  Script: RDataEngineer-05-04.R
  AnswerTests: rdataengineer_05_04(answer04.1, answer04.2, answer04.3)
- Class: text
  Output: |
    接下來我們跟同學介紹R 在2014年開始發展的一種寫法，稱作「pipeline operator」。
- Class: text
  Output: |
    在剛剛的練習中，同學可能會寫出如：`summarise(filter(flights, ...))`的程式碼。
    或是使用大量的暫存變數，如：`a1 <- filter(flights, ...)`以及`a2 <- summarise(a1, ...)`。
    在整理資料的時候，我們常常要對數據做連續的操作（例如:先`filter`再進行`summarise`等）
- Class: text
  Output: |
    這時後，我們可能只能建立大量的暫存變數，如`a1`，`a2`，或者是寫出不好讀的程式碼，
    如：`summarise(filter(flights, ...))`
- Class: text
  Output: |
    在dplyr中導入了magrittr在2014年的發明：pipeline operator，`%>%`。
    `%>%`會將上一個函數的輸出，放到後面函數的第一個參數。
    也就是說，上述的程式碼可以改寫成：`filter(flights, ...) %>% summarise(...)`。
- Class: text
  Output: |
    而`%>%`是可以串接的，所以實務上，我們就可以寫出：`filter(flights, ...) %>% select(...) %>% mutate(...) %>% summarise`。
    每一個函數的輸出，都是下一個函數的第一個參數（也就是要進行處理的data.frame）。
    所以這段程式碼中，`filter`的輸出就交給`select`處理後，再交給`mutate`，最後給`summarise`。
    各位同學從這邊，就可以看出dplyr在設計函數時所下的苦心。
- Class: text
  Output: |
    使用`%>%`寫程式，不只不需要命名大量的變數，如：`a1`、`a2`等，
    程式碼的看起來也比`summarise(mutate(select(filter(flights, ...), ...), ...), ...)`簡單的多了。
- Class: text
  Output: |
    請同學將剛剛做的檔案：RDataEngineer-05-04.R 再讀一次。
    我們需要再做一次這一個練習。
- Class: script
  Output: |
    請同學用`%>%`完成剛剛的 RDataEngineer-05-04.R。
    請在完成之後存檔，並輸入`submit()`來檢查結果是否符合預期。
    如果同學在檔案中看到亂碼，請使用Rstudio 左上角的File -> Reopen。
  Script: RDataEngineer-05-04.R
  AnswerTests: rdataengineer_05_04(answer04.1, answer04.2, answer04.3)
- Class: text
  Output: |
    剛剛的第一個練習題（answer04.1），我們計算了一月份平均的gain（arr_delay - dep_delay）。
    但是如果我們要計算一月、二月到十二月份平均的gain，並且做比較，要怎麼做呢？
- Class: text
  Output: |
    同學可能會想利用`lapply`、`sapply`甚至是寫迴圈來解決這個問題。
- Class: text
  Output: |
    dplyr提供了函數`group_by`來解決這樣的問題。
    它讓我們依照某個欄位，將整個資料切割成若干份。
    之後，我們對它（經過`group_by`處理後的data.frame）做的動作都會同步作用在每一份資料中(data.frame)。
- Class: cmd_question
  Output: |
    舉例來說，我們可以用`df <- group_by(flights, month)`，先用`group_by`標記要根據`month`對flights的資料做分割。
    並且把這個動作的結果存到`df`變數中。
    請同學試試看。
  CorrectAnswer: df <- group_by(flights, month)
  AnswerTests: omnitest('df <- group_by(flights, month)')
  Hint: df <- group_by(flights, month)
- Class: script
  Output: |
    接著，我們將剛剛解答`answer04.1`的動作中，扣掉`filter`的部份，再做一次。
    請同學看看改過之後的結果，輸入`submit()`即可。這題不用對程式進行修改。
  Script: RDataEngineer-05-05.R
  AnswerTests: rdataengineer_05_05(answer05)
- Class: cmd_question
  Output: |
    讓我們看看結果吧。請同學輸入：`answer05`。
  CorrectAnswer: answer05
  AnswerTests: omnitest('answer05')
  Hint: answer05
- Class: text
  Output: |
    是不是很輕鬆就可以算出每個月份的gain的平均呢？
- Class: text
  Output: |
    這裡建議同學一個在實務上撰寫`gruop_by`的思路。
    首先，我們針對某個欄位（例如月份）做`filter`，挑出特定的類別。
    並對`filter`的結果做不同的操作，回答並解決相對應的問題。
    當我們想要把`filter`之後的動作，重複的操作在每一種類別（例如每一個月份）時，只要把`filter`換掉改成`group_by`，後面的步驟照舊即可得到答案。
- Class: text
  Output: |
    以上的內容就是這門課程對dplyr的介紹。
    為了下一個課程，我們要做最後一個練習。
- Class: cmd_question
  Output: |
    變數`cl_info`記載著從金管會銀行局的一般銀行及信用合作社消費者貸款業務項目。
    同學可以使用`View(cl_info)`看一看資料。
  CorrectAnswer: View(cl_info)
  AnswerTests: omnitest('View(cl_info)')
  Hint: View(cl_info)
- Class: text
  Output: |
    這個練習是要對這個資料做一連串的整理之後，算出每個月份的銀行房貸放款數量。
    這個數字會和我國的房地產是否泡沫化有關。
- Class: script
  Output: |
    請在完成之後存檔，並輸入`submit()`來檢查結果是否符合預期。
    如果同學在檔案中看到亂碼，請使用Rstudio 左上角的File -> Reopen
  Script: RDataEngineer-05-06.R
  AnswerTests: rdataengineer_05_06(cl_info2, cl_info3)

