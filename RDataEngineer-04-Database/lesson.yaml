- Class: meta
  Course: DataScienceAndR
  Lesson: RDataEngineer-04-Database
  Author: Wush Wu
  Type: Standard
  Organization: Taiwan R User Group
  Version: 2.3.1.1
- Class: text
  Output: 這次個課程將著重於如何用R 讀寫關聯式資料庫。**因為本次課程會操作資料庫，所以在接關 功能上會有些狀況。同學請儘量一口氣完成這門課程**
- Class: text
  Output: 資料庫（Database）泛指能夠儲存資料的檔案櫃。使用者可以對檔案中的資料進行：新增、擷取、更新和刪除。
- Class: text
  Output: |
    關聯式資料庫（Relational database），是近代資訊科學發展得非常成熟的一個領域。成熟到
    目前當人們提到「資料庫」時，在沒有額外說明下，通常都是指「關聯式資料庫」。
- Class: text
  Output: 關聯式資料庫背後的設計，是牽涉到一種叫「Relational Model」的數學，並且由許多 資訊科學的學者發展出的理論在背後支撐。而關聯式資料庫設計的成功，則可以從現代資訊科學在
    企業的應用層面所體現。
- Class: text
  Output: 在現代資訊時代，幾乎我們日常生活中所碰觸到的重要資訊，都過經過關聯式資料庫。 例如購票系統、會計系統、倉儲系統等等。關聯式資料庫的設計是可以滿足廣泛系統的需要。
- Class: text
  Output: 而有數據的地方，就有潛在的分析需求。R 語言身為大數據時代最火熱的工具之一， 在與各種資料庫系統的串接上，自然有一席之地。
- Class: text
  Output: 這次課程中我們會描述R 語言如何透過DBI和其系列套件為例，操作關聯式資料庫。 而這裡我們以SQLite這套精巧的關聯式資料庫系統為例。
- Class: text
  Output: |
    在課程開始之前，我們也要先跟各位同學聲明，這次的教學並不會碰到太多資料庫的設計與效能問題。
    這些問題都是需要搭配系統的架構後，才能妥善解決的問題。我們也要先警告同學，如果直接用R 大量
    的撈取線上資料庫，是有可能影響資料庫的效能的。所以如果在實務使用時，最好是先知會與請教負責資料庫
    系統的同仁。
- Class: cmd_question
  Output: 請同學先安裝RSQLite套件。它是R 與SQLite資料庫之間的橋樑。專業的術語叫：「客戶端」（Client）
  CorrectAnswer: check_then_install("RSQLite", "1.0.0")
  AnswerTests: test_package_version("RSQLite", "1.0.0")
  Hint: install.packages("RSQLite")
- Class: cmd_question
  Output: 請同學載入RSQLite
  CorrectAnswer: library(RSQLite)
  AnswerTests: test_search_path("RSQLite")
  Hint: library(RSQLite)
- Class: text
  Output: 雖然目前在市面上，有許多的SQL 資料庫，但是在R 中操作起來，都是非常類似的。 因為R 都是透過DBI 套件所定義的函數，讓使用者操作資料庫。
- Class: text
  Output: 等一下我們要帶同學作一次SQLite 資料庫的連線、寫入資料、讀取資料、更改資料和刪除資料。 這樣的操作是最基本的，並且未來當同學在使用R 操作其他資料庫，甚至是NoSQL等外部儲存裝置，
    使用的要領也是如此：連線、寫入、讀取、更改和刪除。
- Class: cmd_question
  Output: 我們先連接SQLite 資料庫，再跟同學繼續解釋。我們已經事先準備了一個SQLite 資料庫的檔案，並且把路徑存在：`db_path`變數之中。請同學先輸入：`drv
    <- dbDriver("SQLite")`， 取得連接SQLite 資料庫的方式。
  CorrectAnswer: drv <- dbDriver("SQLite")
  AnswerTests: omnitest('drv <- dbDriver("SQLite")')
  Hint: drv <- dbDriver("SQLite")
- Class: cmd_question
  Output: 接著我們建立一個SQLite 資料庫的連線：`db <- dbConnect(drv, db_path)`
  CorrectAnswer: db <- dbConnect(drv, db_path)
  AnswerTests: omnitest('db <- dbConnect(drv, db_path)')
  Hint: db <- dbConnect(drv, db_path)
- Class: text
  Output: |
    這裡的`db`物件，就是這個資料庫在R 的代理人。後續若要從這個資料庫作任何動作，
    通常都要把`db`這個物件當成函數的參數之一。在DBI的文件中會把`db`這種角色的物件記載為：
    `connection`
- Class: cmd_question
  Output: |
    接著我們來嘗試把這筆數據寫入SQL 資料庫之中。在DBI界面中，提供了`dbWriteTable`這個
    函數，所以請大家先打開這個函數的說明頁面。
  CorrectAnswer: ?dbWriteTable
  AnswerTests: any_of_exprs("?dbWriteTable", "help(dbWriteTable)", 'help("dbWriteTable")')
  Hint: ?dbWriteTable
- Class: text
  Output: |
    各位同學應該可以在說明視窗的左上角看到：`dbReadTable {DBI}`的字樣。這代表我們目前操作
    的函數，是DBI套件所提供的功能。而dbReadTable和dbWriteTable的說明頁面是寫在同一頁的，
- Class: mult_question
  Output: 請問下列哪一個選項「不是」DBI套件`dbWriteTable`的參數？
  AnswerChoices: conn;name;value;overwrite
  CorrectAnswer: overwrite
  AnswerTests: omnitest(correctVal = "overwrite")
- Class: cmd_question
  Output: |
    因為`db`是RSQLite提供的資料庫代理人（當初的`drv`是`dbDriver("SQLite")`)，所以
    除了DBI的`dbWriteTable`之外，我們還有額外的參數可以使用。請同學輸入：
    `help.search("dbWriteTable")`
  CorrectAnswer: help.search("dbWriteTable")
  AnswerTests: omnitest('help.search("dbWriteTable")')
  Hint: help.search("dbWriteTable")
- Class: cmd_question
  Output: |
    R 應該會列出至少兩個dbWriteTable的說明，並且其中一個是來自RSQLite。在Rstudio下，同學
    只要用滑鼠去點選連結即可。但是限於swirl環境，還是需要同學輸入以下指令（或是`skip()`）
    `help("dbWriteTable,SQLiteConnection,character,data.frame-method")`
    使用R 原生環境的同學平時也得利用上述指令查詢RSQLite提供的dbWriteTable
  CorrectAnswer: help("dbWriteTable,SQLiteConnection,character,data.frame-method")
  AnswerTests: omnitest('help("dbWriteTable,SQLiteConnection,character,data.frame-method")')
  Hint: help("dbWriteTable,SQLiteConnection,character,data.frame-method")
- Class: mult_question
  Output: 此時的說明頁面左上角，應該會註明這份文件是來自RSQLite套件。請同學參考文件內容後， 回答：`overwrite`是不是dbWRiteTable的參數呢？
  AnswerChoices: yes;no
  CorrectAnswer: 'yes'
  AnswerTests: omnitest(correctVal="yes")
- Class: text
  Output: 這是R 在處理SQL 資料庫的設計。如果使用者只有操作到DBI的dbWriteTable提供的功能，那 未來相同的程式碼，運作在其他的資料庫系統時，不需要太大的修改即可運作。但是如果是用了RSQLite
    提供的功能（如overwrite），那在切換資料庫時，就要看新的資料庫的R 套件有沒有提供類似的功能。
- Class: text
  Output: 在解釋`dbWriteTable`之前，我們要先對資料庫系統有一點簡單的認知。資料庫在處理數據時， 會將數據放在一個又一個的表格中。這感覺非常類似R
    會把一個data.frame存放到對應的變數之中。
- Class: text
  Output: 回到`DBI::dbWriteTable(connection, name, value, ...)`的說明，R 就會嘗試透過 connection物件，把value的data.frame寫入到名稱為name的表格中。
- Class: cmd_question
  Output: |
    舉例來說，我們現在想要把`lvr_land`這個記載實價登錄資訊的表格，寫到SQLite資料庫中。
    請同學利用指令：`head(lvr_land)`看一下這個資料集。
  CorrectAnswer: head(lvr_land)
  AnswerTests: omnitest("head(lvr_land)")
  Hint: head(lvr_land)
- Class: cmd_question
  Output: |
    我們看一下`lvr_land`這個資料集。這是取自我們政府的實價登錄資料。請同學輸入：
    `head(lvr_land)`
  CorrectAnswer: head(lvr_land)
  AnswerTests: omnitest('head(lvr_land)')
  Hint: head(lvr_land)
- Class: text
  Output: 欄位名稱很清楚的註明每個欄位的數據意義。
- Class: cmd_question
  Output: |
    接著，我們透過`dbWriteTable`將實價登錄資料寫入資料庫中。請同學輸入：
    `dbWriteTable(db, "lvr_land2", lvr_land)`
  CorrectAnswer: dbWriteTable(db, "lvr_land2", lvr_land)
  AnswerTests: check_lvr_land(db)
  Hint: dbWriteTable(db, "lvr_land2", lvr_land)
- Class: text
  Output: |
    這樣的動作，就非常類似在R 中執行：`lvr_land2 <- <lvr_land的值>`，差別在於lvr_land2
    這個名字是一個SQLite資料庫的表格。
- Class: text
  Output: |
    R 的大部分的資料庫套件，在`dbWriteTable`函數中都會提供`append`和`overwrite`兩個參數。
- Class: text
  Output: |
    `overwrite = TRUE` 時，R 會自動把撞名的表格刪除，並且寫入新的資料。如果是`overwrite = FALSE`
    時撞名，R 就會出錯。由於讓同學測試的話，swirl會跳掉，所以我們這邊就只能先帶過了。
- Class: text
  Output: |
    `append = TRUE`時，R 會把我們要寫入的資料，接在撞名的表格之下。這等介紹完`dbReadTable`
    之後，我們再試試。
- Class: cmd_question
  Output: |
    接下來，我們透過`dbReadTable`來從表格中取出資料。這個指令只需要兩個參數：`connection`
    和`name`。請同學輸入：`dbReadTable(db, "lvr_land2")`，同學就應該可以看到剛剛的數據。
  CorrectAnswer: dbReadTable(db, "lvr_land2")
  AnswerTests: omnitest('dbReadTable(db, "lvr_land2")')
  Hint: dbReadTable(db, "lvr_land2")
- Class: cmd_question
  Output: |
    我們可以再寫入一次`lvr_land`，並且設定`append = TRUE`。請同學試試看輸入：
    `dbWriteTable(db, "lvr_land2", lvr_land, append = TRUE)`
  CorrectAnswer: dbWriteTable(db, "lvr_land2", lvr_land, append = TRUE)
  AnswerTests: omnitest('dbWriteTable(db, "lvr_land2", lvr_land, append = TRUE)')
  Hint: dbWriteTable(db, "lvr_land2", lvr_land, append = TRUE)
- Class: cmd_question
  Output: |
    請再次執行`dbReadTable(db, "lvr_land2")`，讀取"lvr_land2"表格看看。
  CorrectAnswer: dbReadTable(db, "lvr_land2")
  AnswerTests: omnitest('dbReadTable(db, "lvr_land2")')
  Hint: dbReadTable(db, "lvr_land2")
- Class: text
  Output: 這次我們應該看到38筆資料（因為lvr_land總共有19筆資料，寫入兩次後應該有38筆）， 如果不幸需要接關的同學可能看到更多筆...
- Class: cmd_question
  Output: |
    `dbListTables(db)`可以列出目前已經存在於資料庫的表格。請同學試試看。
  CorrectAnswer: dbListTables(db)
  AnswerTests: omnitest('dbListTables(db)')
  Hint: dbListTables(db)
- Class: cmd_question
  Output: |
    請試著用`iris2 <- dbReadTable(db, "iris")`來將剛剛看到的`iris`表格讀出，
    並存入變數`iris2`。這是我是前先把R 內建的iris資料集寫入資料庫後產生的表格。
  CorrectAnswer: iris2 <- dbReadTable(db, "iris")
  AnswerTests: omnitest('iris2 <- dbReadTable(db, "iris")')
  Hint: iris2 <- dbReadTable(db, "iris")
- Class: cmd_question
  Output: |
    如同RDataMining-03中看到jsonlite的vignette，我們可以用`all.equal(iris, iris2)`
    來比較看看兩者是不是一模一樣。
  CorrectAnswer: all.equal(iris, iris2)
  AnswerTests: omnitest('all.equal(iris, iris2)')
  Hint: all.equal(iris, iris2)
- Class: text
  Output: |
    同學應該會看到：`"Component “Species”: 'current' is not a factor"`的字樣，這代表
    當我們從資料庫中把iris拿出來後，Species的型態改變了。
- Class: text
  Output: |
    型態改變這件事情，其實是可大可小的。在大部分的狀況下，例如建立統計模型、製作圖表，factor
    字串（character）的互換並不會帶來太大個困擾。但是在某些很不常見的狀況下（如`strsplit`在
    遇到factor的時候會出錯），可能會導致程式出錯。這是很討厭的。
- Class: text
  Output: |
    我有開發過大型R 的應用系統的經驗，而像這類型態不符的地方，往往會導致系統產生無法預期的結果。
    舉例來說，當我嘗試把資料處理的流程搬入資料庫後，某些原本可以運作的程式碼就壞掉了（就是`strsplit`）。
- Class: text
  Output: |
    我猜大部分的R 使用者，大概都不用管到這件事情，但是如果有一天當R 不聽你話的時候，請記得檢查
    這些小地方。
- Class: text
  Output: |
    剛剛我們講解的`dbReadTable`和`dbWriteTable`都是一次把所有資料倒進去和拿出來的方法，
    雖然方便，但是當數據量很大的時候，我們可能想要一次只拿一部分的資料。進階的使用者可能需要
    更多關聯式資料庫所提供的功能。
- Class: cmd_question
  Output: |
    DBI界面中，我們可以利用`dbGetQuery`和`dbSendQuery`來執行SQL語句。SQL是操作關聯式資料庫
    必學的工具，也是資料科學家必備的工具之一。請同學執行：
    `dbGetQuery(db, "SELECT * FROM iris WHERE species = \"virginica\"")`
  CorrectAnswer: dbGetQuery(db, "SELECT * FROM iris WHERE species = \"virginica\"")
  AnswerTests: omnitest('dbGetQuery(db, "SELECT * FROM iris WHERE species = \\"virginica\\"")')
  Hint: dbGetQuery(db, "SELECT * FROM iris WHERE species = \"virginica\"")
- Class: text
  Output: |
    剛剛的`"SELECT * FROM iris WHERE species = \"virtinica\""`是一段SQL expression。
    而`dbGetQuery`會解析這樣的SQL expression，並且依照指令進行資料庫的操作後，再把結果直接
    回傳給R 。
- Class: cmd_question
  Output: |
    `dbSendQuery`函數則會先把結果儲存於Result物件中，再由使用者一段一段的取出。
    請同學試著執行：`rs <- dbSendQuery(db, "SELECT * FROM iris")`
  CorrectAnswer: rs <- dbSendQuery(db, "SELECT * FROM iris")
  AnswerTests: omnitest('rs <- dbSendQuery(db, "SELECT * FROM iris")')
  Hint: rs <- dbSendQuery(db, "SELECT * FROM iris")
- Class: cmd_question
  Output: 上一關所拿到的`rs`物件，就是整個資料集的「代理」。我們可以利用`fetch`方法， 一次拿一點資料出來。請同學試試看：`fetch(rs,
    1)`
  CorrectAnswer: fetch(rs, 1)
  AnswerTests: omnitest('fetch(rs, 1)')
  Hint: fetch(rs, 1)
- Class: cmd_question
  Output: 請同學再試一次：`fetch(rs, 1)`（你可以按一下 ↑ ，正常安裝的R 會顯示上一個輸入）
  CorrectAnswer: fetch(rs, 1)
  AnswerTests: omnitest('fetch(rs, 1)')
  Hint: fetch(rs, 1)
- Class: text
  Output: 同學應該會注意到，兩次的結果是不同的。這是因為在第一次`dbSendQuery`指令完成之後， R 和資料庫就把結果暫存到某個地方，並且將代理物件回傳，而這就是`rs`。之後每次執行`fetch`
    指令時，R 就會「依照順序」把結果一個又一個的回傳給使用者。如果使用者每次想多拿一些資料，則 可以使用第二個參數，如：`fetch(rs, 100)`一次取出100筆資料。
- Class: cmd_question
  Output: 當我們不需要再使用`rs`物件時，就刪除它：`dbClearResult(rs)`請同學試試看。
  CorrectAnswer: dbClearResult(rs)
  AnswerTests: omnitest('dbClearResult(rs)')
  Hint: dbClearResult(rs)
- Class: text
  Output: |
    `dbSendQuery`和`fetch`的技巧在使用R 處理「大量資料」，是非常有用的。尤其是當資料量
    「超過記憶體」時，運用資料庫來優化在硬碟上處理資料的效能，是很有效率的方式。此時，如果
    我們的演算法是不需要一次看到所有的資料，那`dbSendQuery`和`fetch`的方式就非常有用，
    避免我們發生滑鼠不能移動的悲劇。
- Class: text
  Output: |
    上述的課程中，我們並沒有講解SQL expression。同學如果有興趣的話，可以再找SQL相關的資料
    學習。反之，我們把這部份的細節，留待後續`dplyr`套件的系列課程中，再跟同學介紹。
    我們這裡想要強調的是，所有對資料庫的基礎操作，DBI有提供一些輔助函數，例如：`dbGetQuery`、
    `dbSendQuery`
- Class: text
  Output: 最後，我們示範資料庫的transaction功能。這在處理資料時，也是非常重要的事情。
- Class: text
  Output: |
    當我們在運用外部資源（如資料庫、如檔案系統）處理資料時，最害怕的狀況是被意外中斷。
    舉例來說，網路可能剛好斷線、硬碟突然壞軌、或是發生各種平常沒遇到的狀況。這時候除
    了幫工程師買乖乖之外，實務上其實有一些技巧可以避免意外帶來的困擾。
- Class: text
  Output: |
    意外對我們最大的困擾並不是工作中斷。畢竟作分析的工作，畫畫的時候R 掛掉了，就... 重新開R
    再跑一遍就好了。但是當我們正在寫入資料庫時，意外的中斷就會帶來以下的困擾。
- Class: text
  Output: |
    當我們排除意外的原因，要繼續工作時，就會問：目前資料庫的狀態，是「還未寫入」、「寫到一半」還是
    「寫入完畢」。「還未寫入」的狀況下，我們只要重新執行程式即可。而「寫入完畢」的話就更棒了，我們
    只要繼續後續的工作。但是若是「寫到一半」的狀態，要接著工作就會非常麻煩（可能要改程式碼）。
- Class: text
  Output: |
    Transaction就是一種保證資料庫的狀態一定是「還未寫入」或是「寫入完畢」的機制。
- Class: cmd_question
  Output: |
    在R 裡面，我們可以利用`dbBegin(db)`來開啟一個Transaction。請同學試試看。
  CorrectAnswer: dbBegin(db)
  AnswerTests: omnitest('dbBegin(db)')
  Hint: dbBegin(db)
- Class: cmd_question
  Output: |
    接著，讓我們利用`dbRemoveTable(db, "CO2")`來刪除"CO2"表格。
  CorrectAnswer: dbRemoveTable(db, "CO2")
  AnswerTests: omnitest('dbRemoveTable(db, "CO2")')
  Hint: dbRemoveTable(db, "CO2")
- Class: cmd_question
  Output: |
    請同學用`dbListTables(db)`來檢查"CO2"是不是已經消失在表格清單之中。
  CorrectAnswer: dbListTables(db)
  AnswerTests: omnitest('dbListTables(db)')
  Hint: dbListTables(db)
- Class: cmd_question
  Output: |
    請同學輸入`dbDisconnect(db)`，模擬當意外發生時與資料庫的連線中斷的狀況。
  CorrectAnswer: dbDisconnect(db)
  AnswerTests: omnitest('dbDisconnect(db)')
  Hint: dbDisconnect(db)
- Class: cmd_question
  Output: |
    請同學輸入`db <- dbConnect(drv, db_path)`重新連接資料庫。
  CorrectAnswer: db <- dbConnect(drv, db_path)
  AnswerTests: omnitest('db <- dbConnect(drv, db_path)')
  Hint: db <- dbConnect(drv, db_path)
- Class: cmd_question
  Output: |
    請同學用`dbListTables(db)`來檢查"CO2"是不是又重出江湖了？
  CorrectAnswer: dbListTables(db)
  AnswerTests: omnitest('dbListTables(db)')
  Hint: dbListTables(db)
- Class: text
  Output: |
    除了中斷連線，我們也可以主動使用`dbRollback(db)`指令把資料庫的狀態復原至我們執行
    `dbBegin(db)`的時間點。
- Class: cmd_question
  Output: |
    再請同學輸入：`dbBegin(db)`
  CorrectAnswer: dbBegin(db)
  AnswerTests: omnitest('dbBegin(db)')
  Hint: dbBegin(db)
- Class: cmd_question
  Output: |
    接著，讓我們利用`dbRemoveTable(db, "CO2")`再刪除"CO2"表格一次。
  CorrectAnswer: dbRemoveTable(db, "CO2")
  AnswerTests: omnitest('dbRemoveTable(db, "CO2")')
  Hint: dbRemoveTable(db, "CO2")
- Class: cmd_question
  Output: |
    這次我們輸入`dbCommit(db)`
  CorrectAnswer: dbCommit(db)
  AnswerTests: omnitest('dbCommit(db)')
  Hint: dbCommit(db)
- Class: cmd_question
  Output: |
    請同學用`dbListTables(db)`來檢查"CO2"是不是確實消失了？
  CorrectAnswer: dbListTables(db)
  AnswerTests: omnitest('dbListTables(db)')
  Hint: dbListTables(db)
- Class: text
  Output: 之後，就算我們斷線從連，CO2也不會回來了。
- Class: text
  Output: |
    總而言之，當我們開始`dbBegin(db)`之後，所有的變更，都要等到我們執行`dbCommit(db)`才會生效。
    中間只要發生任何狀況：無論是我們主動`dbRollback(db)`，或是發生意外導致斷線，資料庫
    都會自動復原至我們執行`dbBegin(db)`時的狀態。這招在寫入大量數據時，也是很重要的技巧。
    這個技巧可以保證我們的「資料正確性」
- Class: text
  Output: |
    資料庫還有許多處理資料的技術與手法，例如JOIN等相關技術。但是這都牽涉到SQL語法的學習，
    而且各家資料庫系統在這部份的語法也會略有差異，所以本次課程僅著重於R 與資料庫之間的簡易操作，
    以及基礎概念。
- Class: script
  Output: |
    最後還是請各位同學利用以上學習的內容，操作一次資料庫系統。
    請同學在完成之後存檔，並輸入`submit()`來檢查結果是否符合預期。
    如果同學在檔案中看到亂碼，請使用Rstudio 左上角的File -> Reopen
  Script: RDataEngineer-04-HW.R
  AnswerTests: rdataengineer_04_hw_test()

