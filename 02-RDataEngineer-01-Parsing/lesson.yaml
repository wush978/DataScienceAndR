- Class: meta
  Course: DataScienceAndR
  Lesson: 02-RDataEngineer-01-Parsing
  Author: Wush Wu
  Type: Standard
  Organization: Taiwan R User Group
  Version: 2.3.1
- Class: text
  Output: |
    這門課程將會帶大家走過一遍R 所提供的字串處理功能。
- Class: text
  Output: |
    在實務上，數據來源經常是隱含某些規則的文字檔案。
    例如：伺服器依據工程師擬定的規則所產生的資料。
    這個規則可能是工程師自己訂的，也可能是符合眾人智慧所訂定的規範。
- Class: text
  Output: |
    但是不管是工程師自己的想法，或是眾人的智慧，R 都能從文字中萃取出資訊。
    這樣的技術就稱作Parsing。
    同學上一堂課程所學到的`read.table`，其實就是Parsing的其中一種功能。
- Class: text
  Output: |
    這個課程中，我們事先從政府的公開資料平台抓取了血清白蛋白(Albumin)檢查比率的資料。
    資料已經存放於`hospital_path`了。
    有興趣的同學，可以參考網址：<http://data.gov.tw/node/25511>閱讀關於這個資料集的故事。
- Class: cmd_question
  Output: |
    請同學用上一堂課所學的方法，先用`readBin`來檢查這個檔案的BOM。
  CorrectAnswer: readBin(hospital_path, "raw", n = 3L)
  AnswerTests: val_is(readBin(hospital_path, "raw", n = 3L))
  Hint: readBin(hospital_path, "raw", n = 3L)
- Class: mult_question
  Output: |
    請問同學，根據這三個byte，他們的BOM可能是什麼呢？
  AnswerChoices: UTF-8(EF BB BF);UTF-16BE(FE FF);UTF-16LE(FF FE);Unknown
  CorrectAnswer: Unknown
  AnswerTests: omnitest(correctVal = "Unknown")
  Hint: 請比對R 讀取`hospital_path`前三Byte的值與常見的BOM值
- Class: cmd_question
  Output: |
    當BOM無法被判斷的時候，我們只好用不同Encoding讀取資料最初幾行試試看。
    由於政府公開資料網宣稱這個檔案為UTF-8編碼的，我們先使用UTF-8讀讀看。
    請同學輸入：`readLines(file(hospital_path, encoding = "UTF-8"), n = 6)`
  CorrectAnswer: readLines(file(hospital_path, encoding = "UTF-8"), n = 6)
  AnswerTests: omnitest('readLines(file(hospital_path, encoding = "UTF-8"), n = 6)')
  Hint: readLines(file(hospital_path, encoding = "UTF-8"), n = 6)
- Class: cmd_question
  Output: |
    接著我們再使用`readLines(file(hospital_path, encoding = "BIG5"), n = 6)`試試看。
    如果看到警告（warning）訊息，即代表這份檔案並非UTF-8編碼，因而導致的小錯誤。
  CorrectAnswer: readLines(file(hospital_path, encoding = "BIG5"), n = 6)
  AnswerTests: omnitest('readLines(file(hospital_path, encoding = "BIG5"), n = 6)')
  Hint: readLines(file(hospital_path, encoding = "BIG5"), n = 6)
- Class: mult_question
  Output: |
    透過上面的測試，請問同學，這個檔案的編碼是什麼呢?
  AnswerChoices: UTF-8;BIG5
  CorrectAnswer: BIG5
  AnswerTests: omnitest(correctVal = "BIG5")
- Class: text
  Output: |
    像是這類編碼與文件不符的狀況，在實務的例子中是很常見的。
- Class: cmd_question
  Output: |
    接著請同學依照在RBasic-07中所學到的技巧，用`read.table`和`file`兩個函數的組合，並適當的設定`sep`、`header`和`encoding`等參數，將`hospital_path`的內容存到`hospital`之中。
  CorrectAnswer: hospital <- .read.table.big5(hospital_path, header = TRUE, sep =
    ",")
  AnswerTests: check_val("hospital", .read.table.big5(hospital_path, header = TRUE,
    sep = ","))
  Hint: hospital <- read.table(file(hospital_path, encoding = "BIG5"), sep = ",",
    header = TRUE)
- Class: cmd_question
  Output: |
    如果希望從欄位YEARYY中擷取出資料的年份。
    我們先看看名稱為YEARYY這欄，請同學自hospital中選出YEARYY欄位。
    （同學可以使用`[[`、或`$`搭配名稱或是欄位順序）
  CorrectAnswer: hospital$YEARYY
  AnswerTests: val_is(hospital[[1]])
  Hint: hospital$YEARYY
- Class: text
  Output: |
    有時候，觀察到太大量的資料可能會對R 、電腦帶來大量的負荷，同時也對我們沒有意義。
    因為我們能同時處理的資料量是有限的。
    這部份建議同學可以用`head`這個函數篩選出資料的前6 列做觀察。
- Class: mult_question
  Output: |
    請問同學，`hospital`中YEARYY欄位的型態為何？
  AnswerChoices: character;factor;integer;numeric;list
  CorrectAnswer: factor
  AnswerTests: omnitest(correctVal = "factor")
  Hint: 請注意，R 回報說這個欄位有36個Levels。
- Class: cmd_question
  Output: |
    Levels上的資訊顯示，年份的資訊，可能位於前兩個或前三個數字。
    如果都是兩個數字的話，我們可以透過`substring`函數直接擷取字串中的段落。
    請同學輸入：`?substring`先看看substring函數的說明文件。
  CorrectAnswer: ?substring
  AnswerTests: any_of_exprs("?substring", "help(substring)", 'help("substring")')
  Hint: ?substring
- Class: mult_question
  Output: |
    請問下列哪一個「不是」`substring`的參數？
  AnswerChoices: x;text;first;last
  CorrectAnswer: x
  AnswerTests: omnitest(correctVal = "x")
- Class: cmd_question
  Output: |
    R 的`substring`函數可以將`text`參數代表的字串中，依照字符的位置，擷取出中間的段落。
    舉例來說，`substring("abc", 1, 2)`就會擷取出"abc"中第1 個字母到第2 個字母的段落，也就是"ab"。
    而`substring`也是向量式的函數。
    請同學輸入`substring(head(hospital$YEARYY), 1, 3)`看看前6 筆數據經過R 的`substring`函數處理之後的結果。
  CorrectAnswer: substring(head(hospital$YEARYY), 1, 3)
  AnswerTests: omnitest("substring(head(hospital$YEARYY), 1, 3)")
  Hint: substring(head(hospital$YEARYY), 1, 3)
- Class: text
  Output: |
    有時候這樣的作法就夠了，可惜在現在的狀況不適合。
    因為年度可能是2 位數也可能是3 位數。
- Class: cmd_question
  Output: |
    另外一種想法則是拿`"Q"`當做定位點。
    我們如果利用`"Q"`把字串分割成兩部份，第一部份就是我們需要的年份了。
    在R 中，可以運用函數`strsplit`達到這個目的。
    請同學打開`strsplit`的說明文件。
  CorrectAnswer: ?strsplit
  AnswerTests: any_of_exprs("?strsplit", "help(strsplit)", 'help("strsplit")')
  Hint: ?strsplit
- Class: mult_question
  Output: |
    請問同學，下列哪一個「不是」`strsplit`的參數？
  AnswerChoices: x;split;fixed;str
  CorrectAnswer: str
  AnswerTests: omnitest(correctVal="str")
- Class: cmd_question
  Output: |
    根據說明文件，`strsplit`會利用`split`參數來切割`x`字串，並回傳一個`list`。
    因為`x`的長度可能超過1 ，而`strsplit`會用`split`去切割每一個`x`的元素。
    而切割出來的結果，第一個元素可能切出兩段，但是第二個元素可能只切出一段。
    所以R 使用`list`這個結構來處理。
    但是`strsplit`並不接受factor參數，只接受字串向量。
    因此請同學用：`yearyy <- as.character(hospital$YEARYY)`將資料存到`yearyy`這個變數中。
  CorrectAnswer: yearyy <- as.character(hospital$YEARYY)
  AnswerTests: omnitest("yearyy <- as.character(hospital$YEARYY)")
  Hint: yearyy <- as.character(hospital$YEARYY)
- Class: cmd_question
  Output: |
    接著請同學輸入：`tmp <- strsplit(yearyy, "Q")`，把切割的結果儲存到`tmp`這個變數。
  CorrectAnswer: tmp <- strsplit(yearyy, "Q")
  AnswerTests: omnitest('tmp <- strsplit(yearyy, "Q")')
  Hint: tmp <- strsplit(yearyy, "Q")
- Class: cmd_question
  Output: |
    請同學輸入：`head(tmp)`看看結果。
  CorrectAnswer: head(tmp)
  AnswerTests: omnitest("head(tmp)")
  Hint: head(tmp)
- Class: text
  Output: |
    這時，同學會看到裝著許多字串向量的list。
    這樣的list，甚至是更複雜的結構，都是在處理文字資料時經常遇到的。
- Class: cmd_question
  Output: |
    由於我們需要的是在`"Q"`之前的文字，而在經過`strsplit`處理後，這些文字會在每個list元素的第一個。
    請同學先用`[[`拿出tmp的第一個字串向量元素，然後用`[`拿出這個字串向量的第一個值。
    該值即為第一筆資料的年度。
  CorrectAnswer: tmp[[1]][1]
  AnswerTests: omnitest("tmp[[1]][1]")
  Hint: tmp[[1]][1]
- Class: text
  Output: |
    同樣的要領，如果要取出第二筆資料的年度，只要把上一題`tmp[[1]][1]`的語法改成`tmp[[2]][1]`即可取得。
- Class: cmd_question
  Output: |
    請問同學，`tmp`中總共有多少筆資料呢？
  CorrectAnswer: length(tmp)
  AnswerTests: val_is(length(tmp))
  Hint: length(tmp)
- Class: text
  Output: |
    顯然一個一個處理是不可行的。而R 中當然有針對這種狀況的解法。
    首先請先觀察看看`tmp[[1]][1]`、`tmp[[2]][1]`、`tmp[[3]][1]`有什麼共通性？
    一種觀點是，我們需要對`tmp`的每一個元素進行`[1]`的操作。
- Class: cmd_question
  Output: |
    這樣的需求，在parsing時是十分常見的。
    所以R 提供了`lapply`這個函數。
    請同學先打開`lapply`的說明文件。
  CorrectAnswer: ?lapply
  AnswerTests: any_of_exprs("?lapply", "help(lapply)", 'help("lapply")')
  Hint: ?lapply
- Class: mult_question
  Output: |
    R 的`lapply`是同第一個接觸到的進階函數。
    請問同學，下列哪一個不是`lapply`的參數？
  AnswerChoices: X;FUN;...;Y
  CorrectAnswer: 'Y'
  AnswerTests: omnitest(correctVal="Y")
- Class: text
  Output: |
    `lapply`的第一個參數`X`通常是一個vector。
    第二個參數`FUN`則是代表一種「動作」。
    `lapply`會對每一個`X`的元素進行`FUN`所定義的動作，並且把結果彙整回R 之中。
- Class: mult_question
  Output: |
    如果想要對`tmp`的每一個元素進行`[1]`的操作。
    根據上述的解釋，`lapply`的`X`參數應該要填入什麼呢？
  AnswerChoices: tmp;[[1]];[1]
  CorrectAnswer: tmp
  AnswerTests: omnitest(correctVal = "tmp")
- Class: mult_question
  Output: |
    而`lapply`的`FUN`參數，也就是對每個`X`的元素所進行的動作，應該是以下哪一個呢？
  AnswerChoices: '[1];[[1]]'
  CorrectAnswer: '[1]'
  AnswerTests: omnitest(correctVal="[1]")
- Class: text
  Output: |
    課程進行至此，再解釋一遍給還沒完全理解的同學。
    最一開始我們希望產生的結果，會等於：`c(tmp[[1]][1], tmp[[2]][1], tmp[[3]][1], ...)`，
    在這樣的運算中，第一個`[[1]]`、`[[2]]`、`[[3]]`是變動的，代表著從`tmp`中拿出第一個元素、第二個元素和第三個元素等等。
    而`[1]`則是不變的動作。
- Class: text
  Output: |
    因此`lapply`的第一個參數`X`放的是`tmp`，代表著：`c(FUN(tmp[[1]]), FUN(tmp[[2]]), FUN(tmp[[3]]), ...)`，而此刻我們希望`FUN`作出`[1]`的動作。
    然而，`lapply(tmp, [1])`這種語法是不合邏輯的。
- Class: text
  Output: |
    在R 中，所有的動作都是函數。同理，`[1]`在R 中其實也是一個名叫`[`的函數。
- Class: cmd_question
  Output: |
    因為這個函數比較特別，所以我們使用`lapply(tmp, "[", 1)`這個語法來取出`tmp`中每個元素（字串向量）的第一個欄位。
    請同學試試看。
  CorrectAnswer: lapply(tmp, "[", 1)
  AnswerTests: omnitest('lapply(tmp, "[", 1)')
  Hint: lapply(tmp, "[", 1)
- Class: cmd_question
  Output: |
    如果我們要取出`tmp`中每個元素（字串向量）的第二個欄位，可以用：`lapply(tmp, "[", 2)`取得，請同學試試看。
  CorrectAnswer: lapply(tmp, "[", 2)
  AnswerTests: omnitest('lapply(tmp, "[", 2)')
  Hint: lapply(tmp, "[", 2)
- Class: text
  Output: |
    到目前為止，同學學到`X`和`FUN`這兩個參數在`lapply`中扮演的角色。
    但是最後一個`...`的參數是什麼意思呢？
    因為`lapply`並不清楚執行`FUN`需要什麼樣的參數，所以使用者可以在指定`X`和`FUN`之後，放入任意的參數，
    而這些參數並不是由`lapply`所使用，而是由`FUN`所使用。
- Class: text
  Output: |
    所以`lapply(tmp, "[", 1)`中的第三個參數`1`就會透過`lapply`轉交給`[`。
    如此一來，R 就可以知道要從`tmp`的每個元素中拿出第**1**個元素。
- Class: text
  Output: |
    同理，`lapply(tmp, "[", 2)`的第三個參數`2`透過`lapply`轉交給`[`後，R 就會知道要從`tmp`的每個元素中拿出第**2**個元素。
- Class: mult_question
  Output: |
    接著請教同學，`lapply(tmp, "[", 1)`的輸出結果是什麼型態呢？
  AnswerChoices: list;字串向量(character);整數向量(integer)
  CorrectAnswer: list
  AnswerTests: omnitest(correctVal = "list")
- Class: cmd_question
  Output: |
    list型態對於後續的處理還是比較麻煩的。
    因此在輸出時，通常會希望能夠將轉換為字串向量。
    其中一種做法是透過`unlist`把`lapply`所輸出的`list`拆開。
    請同學試試看先輸入：`tmp2 <- lapply(tmp, "[", 1)`，並將結果儲存到`tmp2`這個變數。
  CorrectAnswer: tmp2 <- lapply(tmp, "[", 1)
  AnswerTests: omnitest('tmp2 <- lapply(tmp, "[", 1)')
  Hint: tmp2 <- lapply(tmp, "[", 1)
- Class: cmd_question
  Output: |
    接著，我們可以使用`unlist(tmp2)`取得字串向量了。
    請同學試試看。
  CorrectAnswer: unlist(tmp2)
  AnswerTests: omnitest("unlist(tmp2)")
  Hint: unlist(tmp2)
- Class: cmd_question
  Output: |
    另外一種方式是使用`sapply`這個函數。
    `sapply`和`lapply`幾乎一樣，差別在於`sapply`最後會嘗試重新整理輸出的格式，將list轉成array。
    請同學試試`sapply(tmp, "[", 1)`。
  CorrectAnswer: sapply(tmp, "[", 1)
  AnswerTests: omnitest('sapply(tmp, "[", 1)')
  Hint: sapply(tmp, "[", 1)
- Class: text
  Output: |
    以上示範的技巧在實務的應用中很常被使用到。
    當我們想要從文字中擷取出資訊時，都可以優先考慮運用`substring`或`strsplit`來擷取資訊。
    而當R 將資訊轉成非結構化的list物件後，可以運用`lapply`或`sapply`做資料的整理。
- Class: text
  Output: |
    事實上，如果同學能夠撰寫R 的函數，就可以適當的將`lapply`與`sapply`作組合，更能有效率的整理資料。
- Class: script
  Output: |
    最後，還是要請同學利用這次所學的內容，做一個小練習。
    請同學在完成之後存檔，並輸入`submit()`來檢查結果是否符合預期。
    如果同學在檔案中看到亂碼，請使用Rstudio 左上角的File -> Reopen
    With Encoding... -> 選取：UTF-8
  Script: RDataEngineer-01-HW.R
  AnswerTests: rdataengineer_01_hw_test()

